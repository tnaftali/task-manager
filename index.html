<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#c06842">
  <meta name="description" content="A personal task management application with drag-and-drop functionality">
  <title>Tobi's Task Manager</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Crect width='24' height='24' rx='6' fill='%23ffffff'/%3E%3Cpath d='M9 11l3 3l8-8' fill='none' stroke='%23c06842' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11' fill='none' stroke='%23c06842' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400..600&display=swap');

    :root {
      /* Modern Beige/Cream Color Scheme */
      --background: #f0ebe3;
      --surface: #f2efea;
      --surface-elevated: #ffffff;
      --border: #e5e0d7;
      --border-hover: #d1ccc1;

      /* Text Colors */
      --text-primary: #2d2a26;
      --text-secondary: #6b6560;
      --text-muted: #9a9389;

      /* Column Colors - Subtle differentiation */
      --todo-accent: #c06842;
      --todo-bg: #f9f7f4;
      --progress-accent: #6b8394;
      --progress-bg: #f4f7f9;
      --done-accent: #7a9471;
      --done-bg: #f6f9f6;

      /* Interactive Elements */
      --accent: #c06842;
      --accent-hover: #a35636;
      --danger: #c85a5a;
      --danger-hover: #b04545;
      --success: #7a9471;
      --warning: #d4a574;

      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(45, 42, 38, 0.04);
      --shadow-md: 0 4px 8px rgba(45, 42, 38, 0.08);
      --shadow-lg: 0 8px 16px rgba(45, 42, 38, 0.12);

      /* Tag Colors - Colorful with good contrast */
      --tag-color-0: #fca5a5; /* Red */
      --tag-color-1: #fdba74; /* Orange */
      --tag-color-2: #fcd34d; /* Amber */
      --tag-color-3: #bef264; /* Lime */
      --tag-color-4: #86efac; /* Green */
      --tag-color-5: #5eead4; /* Teal */
      --tag-color-6: #67e8f9; /* Cyan */
      --tag-color-7: #7dd3fc; /* Sky */
      --tag-color-8: #93c5fd; /* Blue */
      --tag-color-9: #a5b4fc; /* Indigo */
      --tag-color-10: #c4b5fd; /* Violet */
      --tag-color-11: #d8b4fe; /* Purple */
      --tag-color-12: #f0abfc; /* Fuchsia */
      --tag-color-13: #f9a8d4; /* Pink */
      --tag-color-14: #fda4af; /* Rose */
      --tag-color-15: #cbd5e1; /* Slate */
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background-color: var(--background);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 32px;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .title-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-bottom: 48px;
      position: relative;
    }

    h1 {
      text-align: center;
      margin: 0;
      color: rgb(61, 61, 58);
      font-size: 2.25rem;
      font-weight: 500;
      font-family: 'Fraunces', Georgia, serif;
      letter-spacing: -0.01em;
    }

    .title-edit-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.875rem;
      transition: all 0.2s ease;
      opacity: 0.6;
      font-family: inherit;
    }

    .title-edit-btn:hover {
      opacity: 1;
      background-color: var(--surface-elevated);
      color: var(--text-primary);
      border-color: var(--border-hover);
    }

    .title-edit-input {
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 2.25rem;
      font-weight: 500;
      font-family: 'Fraunces', Georgia, serif;
      letter-spacing: -0.01em;
      color: rgb(61, 61, 58);
      min-width: 300px;
      max-width: 600px;
      text-align: center;
      outline: none;
    }

    .title-edit-input:focus {
      border-color: var(--accent);
    }

    .board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
      max-width: 1400px;
      margin: 0 auto;
    }

    .column {
      background-color: var(--surface);
      border-radius: 16px;
      padding: 24px;
      display: flex;
      flex-direction: column;
      height: calc(150vh - 100px);
      max-height: calc(150vh - 100px);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
      transition: all 0.2s ease;
    }

    .column[data-column="todo"] {
      background-color: var(--todo-bg);
      border-color: rgba(139, 115, 85, 0.2);
    }

    .column[data-column="in-progress"] {
      background-color: var(--progress-bg);
      border-color: rgba(107, 131, 148, 0.2);
    }

    .column[data-column="done"] {
      background-color: var(--done-bg);
      border-color: rgba(122, 148, 113, 0.2);
    }

    .column-header {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 24px;
      text-align: center;
      padding: 12px 16px;
      border-radius: 12px;
      background-color: var(--surface-elevated);
      cursor: pointer;
      user-select: none;
      transition: all 0.2s ease;
      position: relative;
      border: 1px solid var(--border);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.875rem;
    }

    .column-header:hover {
      background-color: var(--surface-elevated);
      border-color: var(--border-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .column-header::after {
      content: '‚ñº';
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.75rem;
      opacity: 0.5;
      transition: transform 0.2s ease;
    }

    .column.collapsed .column-header::after {
      transform: translateY(-50%) rotate(-90deg);
    }

    .column.collapsed .tasks-container,
    .column.collapsed .add-task-btn {
      display: none;
    }

    .column-header.todo {
      color: var(--todo-accent);
      border-color: rgba(139, 115, 85, 0.3);
    }

    .column-header.in-progress {
      color: var(--progress-accent);
      border-color: rgba(107, 131, 148, 0.3);
    }

    .column-header.done {
      color: var(--done-accent);
      border-color: rgba(122, 148, 113, 0.3);
    }

    .tasks-container {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 20px;
      padding: 4px;
    }

    .task {
      background-color: var(--surface-elevated);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      cursor: move;
      transition: all 0.2s ease;
      border: 1px solid var(--border);
      position: relative;
      box-shadow: var(--shadow-sm);
    }

    .task:hover {
      border-color: var(--border-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .task.selected {
      border-color: var(--accent);
      box-shadow: var(--shadow-md);
    }

    .task.dragging {
      opacity: 0.6;
      transform: rotate(2deg);
      box-shadow: var(--shadow-lg);
    }

    .task-title {
      font-weight: 500;
      margin-bottom: 8px;
      color: var(--text-primary);
      word-wrap: break-word;
      line-height: 1.4;
      font-size: 0.95rem;
    }

    .task-url-container {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }

    .task-favicon {
      width: 24px;
      height: 24px;
      flex-shrink: 0;
      border-radius: 8px;
      border: 1px solid var(--border);
      background-color: var(--surface);
      padding: 2px;
    }

    .task-url {
      color: var(--accent);
      text-decoration: none;
      font-size: 0.85rem;
      word-break: break-all;
      transition: color 0.2s ease;
    }

    .task-url:hover {
      color: var(--accent-hover);
      text-decoration: underline;
    }

    .task-actions {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 4px;
    }

    .task:not(:hover) .task-actions {
      visibility: hidden;
    }

    .task:hover .task-actions {
      visibility: visible;
    }

    .action-btn {
      background: #ffffff;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      padding: 6px;
      border-radius: 6px;
      font-size: 12px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      box-shadow: var(--shadow-sm);
    }

    .action-btn:hover {
      background: #ffffff;
      color: var(--text-primary);
      border-color: var(--border-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .action-btn.delete:hover {
      color: var(--danger);
      border-color: var(--danger);
      background: #ffffff;
    }

    .action-btn.edit:hover {
      color: var(--accent);
      border-color: var(--accent);
      background: #ffffff;
    }

    .action-btn.duplicate:hover {
      color: var(--accent);
      border-color: var(--accent);
      background: #ffffff;
    }

    .add-task-btn {
      background-color: var(--surface-elevated);
      color: var(--text-muted);
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 16px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s ease;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .add-task-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background-color: rgba(139, 115, 85, 0.05);
      transform: translateY(-1px);
    }

    .drag-over {
      border: 2px dashed var(--accent);
      background-color: rgba(139, 115, 85, 0.1);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(45, 42, 38, 0.6);
      backdrop-filter: blur(4px);
      z-index: 1000;
    }

    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--surface-elevated);
      padding: 32px;
      border-radius: 16px;
      width: 90%;
      max-width: 500px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-lg);
    }

    .modal h3 {
      margin-bottom: 24px;
      color: var(--text-primary);
      font-weight: 600;
      font-size: 1.25rem;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-secondary);
      font-weight: 500;
      font-size: 0.9rem;
    }

    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background-color: var(--surface);
      color: var(--text-primary);
      font-size: 16px;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .form-group textarea {
      resize: vertical;
      min-height: 80px;
    }

    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .btn {
      padding: 12px 24px;
      border: 1px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      font-family: inherit;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }

    .btn-primary {
      background-color: var(--accent);
      color: var(--surface-elevated);
      border-color: var(--accent);
    }

    .btn-primary:hover {
      background-color: var(--accent-hover);
      border-color: var(--accent-hover);
      transform: translateY(-1px);
    }

    .btn-secondary {
      background-color: var(--surface);
      color: var(--text-secondary);
      border-color: var(--border);
    }

    .btn-secondary:hover {
      background-color: var(--surface-elevated);
      color: var(--text-primary);
      border-color: var(--border-hover);
    }

    .loading {
      color: var(--warning);
    }

    .tasks-container::-webkit-scrollbar {
      width: 6px;
    }

    .tasks-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .tasks-container::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }

    .tasks-container::-webkit-scrollbar-thumb:hover {
      background: var(--border-hover);
    }

    .help-text {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background-color: var(--surface-elevated);
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 0.8rem;
      color: var(--text-muted);
      opacity: 0.8;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
    }

    .help-button {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 48px;
      height: 48px;
      background-color: var(--accent);
      color: var(--surface-elevated);
      border: none;
      border-radius: 50%;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: var(--shadow-md);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .help-button:hover {
      background-color: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .instructions-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(45, 42, 38, 0.6);
      backdrop-filter: blur(4px);
      z-index: 1001;
    }

    .instructions-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--surface-elevated);
      padding: 32px;
      border-radius: 16px;
      width: 90%;
      max-width: 700px;
      max-height: 85vh;
      overflow-y: auto;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-lg);
    }

    .instructions-content h2 {
      margin-bottom: 24px;
      color: rgb(61, 61, 58);
      font-size: 1.75rem;
      font-weight: 500;
      font-family: 'Fraunces', Georgia, serif;
    }

    .instructions-content h3 {
      margin-top: 24px;
      margin-bottom: 12px;
      color: var(--text-primary);
      font-size: 1.1rem;
      font-weight: 600;
    }

    .instructions-content p {
      margin-bottom: 12px;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    .instructions-content ul {
      margin-bottom: 16px;
      padding-left: 24px;
    }

    .instructions-content li {
      margin-bottom: 8px;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    .instructions-content kbd {
      background-color: var(--surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 2px 6px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: var(--text-primary);
    }

    .instructions-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 1rem;
      transition: all 0.2s ease;
    }

    .instructions-close:hover {
      background-color: var(--surface);
      color: var(--text-primary);
      border-color: var(--border-hover);
    }

    .sync-indicator {
      position: fixed;
      bottom: 24px;
      left: 24px;
      background-color: var(--surface-elevated);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
      opacity: 1;
      transition: all 0.3s ease;
      color: var(--text-muted);
    }

    .sync-indicator.synced {
      color: var(--success);
      border-color: var(--success);
    }

    .sync-indicator.error {
      color: var(--warning);
      border-color: var(--warning);
    }

    .sync-indicator:hover {
      opacity: 1;
    }

    .task-tags {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .task-tag {
      background-color: var(--surface);
      color: var(--text-secondary);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 500;
      border: 1px solid var(--border);
    }

    .task-notes {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--text-secondary);
      font-style: italic;
      line-height: 1.4;
      white-space: pre-wrap;
    }

    .task.on-hold {
      opacity: 0.6;
      border-left: 4px solid var(--warning);
      background: repeating-linear-gradient(45deg,
          var(--surface-elevated),
          var(--surface-elevated) 10px,
          rgba(212, 165, 116, 0.05) 10px,
          rgba(212, 165, 116, 0.05) 20px);
    }

    .task.on-hold .task-title::before {
      content: '‚è∏ ';
      opacity: 0.7;
    }

    .action-btn.hold:hover {
      color: var(--warning);
      border-color: var(--warning);
      background: #ffffff;
    }

    .task.active {
      border-left: 4px solid var(--accent);
      background: linear-gradient(to right,
          rgba(139, 115, 85, 0.08),
          var(--surface-elevated) 20px);
      box-shadow: var(--shadow-md);
    }

    .task.active .task-title::before {
      content: '‚ñ∂ ';
      color: var(--accent);
      opacity: 0.9;
      font-weight: 600;
    }

    .action-btn.active-btn:hover {
      color: var(--accent);
      border-color: var(--accent);
      background: #ffffff;
    }

    .action-btn.active-btn.is-active {
      background: #ffffff;
      color: var(--accent);
      border-color: var(--accent);
    }

    .date-group {
      margin-bottom: 20px;
    }

    .date-header {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 12px;
      padding: 8px 12px;
      background-color: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .tags-input {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background-color: var(--surface);
      min-height: 44px;
      cursor: text;
      transition: border-color 0.2s ease;
      position: relative;
    }

    .tags-input:focus-within {
      border-color: var(--accent);
    }

    .tag-item {
      background-color: var(--accent);
      color: var(--surface-elevated);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tag-remove {
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      font-size: 0.7rem;
      padding: 0;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tag-remove:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .tag {
      color: #4a4a4a;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 4px;
      font-weight: 500;
    }

    .tag button {
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      font-size: 0.9rem;
      padding: 0;
      line-height: 1;
      opacity: 0.7;
    }

    .tag button:hover {
      opacity: 1;
    }

    .tag-color-btn {
      font-size: 0.6rem !important;
      opacity: 0.5;
      transition: transform 0.2s ease;
    }

    .tag-color-btn:hover {
      opacity: 1 !important;
      transform: scale(1.2);
    }

    .tag-input {
      border: none;
      background: none;
      color: var(--text-primary);
      outline: none;
      flex: 1;
      min-width: 100px;
      font-size: 0.9rem;
    }

    .tag-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--surface-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: var(--shadow-md);
      max-height: 150px;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }

    .tag-suggestion {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.9rem;
      color: var(--text-primary);
      transition: background-color 0.2s ease;
    }

    .tag-suggestion:hover,
    .tag-suggestion.selected {
      background-color: var(--surface);
    }

    .task-time-info {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .time-started {
      font-size: 0.8rem;
      color: var(--text-muted);
      cursor: pointer;
      transition: color 0.2s ease;
      display: inline-block;
    }

    .time-started:hover {
      color: var(--accent);
      text-decoration: underline;
    }

    .task-total-time {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--text-muted);
      font-style: italic;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .task-total-time .time-icon {
      font-size: 0.9rem;
    }

    .task-focus-timer {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .focus-timer-display {
      font-size: 0.9rem;
      color: var(--accent);
      font-weight: 600;
      font-family: 'Courier New', monospace;
      letter-spacing: 0.5px;
    }

    .task-tomatoes {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 1.1rem;
    }

    /* View Navigation */
    .view-nav {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 32px;
    }

    .view-nav-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text-secondary);
      border-radius: 8px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .view-nav-btn:hover {
      border-color: var(--border-hover);
      color: var(--text-primary);
      background: var(--surface-elevated);
    }

    .view-nav-btn.active {
      background: var(--accent);
      color: var(--surface-elevated);
      border-color: var(--accent);
    }

    .view-nav-btn.active:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
    }

    /* Simple List View */
    .list-view {
      max-width: 900px;
      margin: 0 auto;
    }

    .list-container {
      background: var(--surface);
      border-radius: 16px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
    }

    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      background: var(--surface-elevated);
      border-radius: 16px 16px 0 0;
    }

    .list-header-left {
      display: flex;
      align-items: baseline;
      gap: 10px;
    }

    .list-header h2 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 500;
      font-family: 'Fraunces', Georgia, serif;
      color: rgb(61, 61, 58);
    }

    .list-count {
      font-size: 0.85rem;
      color: var(--text-muted);
      font-weight: 400;
    }

    .add-list-item-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 18px;
      background: var(--accent);
      color: var(--surface-elevated);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .add-list-item-btn:hover {
      background: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .add-list-item-btn svg {
      width: 16px;
      height: 16px;
    }

    .list-filter-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      position: relative;
      z-index: 50;
      overflow: visible;
    }

    .list-filter-multiselect {
      position: relative;
      flex: 1;
      max-width: 400px;
    }

    .list-filter-trigger {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: var(--surface-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      min-height: 38px;
      transition: all 0.2s ease;
    }

    .list-filter-trigger:hover {
      border-color: var(--border-hover);
    }

    .list-filter-multiselect.open .list-filter-trigger {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(192, 104, 66, 0.1);
    }

    .list-filter-placeholder {
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .list-filter-selected {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      flex: 1;
    }

    .list-filter-selected:not(:empty) + .list-filter-placeholder {
      display: none;
    }

    .list-filter-selected ~ .list-filter-placeholder {
      flex: 1;
    }

    .list-filter-chevron {
      width: 16px;
      height: 16px;
      color: var(--text-muted);
      transition: transform 0.2s ease;
      flex-shrink: 0;
    }

    .list-filter-multiselect.open .list-filter-chevron {
      transform: rotate(180deg);
    }

    .list-filter-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      background: var(--surface-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: var(--shadow-lg);
      z-index: 100;
      display: none;
      max-height: 200px;
      overflow-y: auto;
    }

    .list-filter-multiselect.open .list-filter-dropdown {
      display: block;
    }

    .list-filter-options {
      padding: 4px;
    }

    .list-filter-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: background 0.15s ease;
    }

    .list-filter-option:hover {
      background: var(--surface);
    }

    .list-filter-option-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .list-filter-option-check {
      width: 16px;
      height: 16px;
      margin-left: auto;
      color: var(--accent);
      opacity: 0;
    }

    .list-filter-option.selected .list-filter-option-check {
      opacity: 1;
    }

    .list-filter-tag {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 3px;
      color: #444;
      font-weight: 500;
    }

    .list-filter-tag button {
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      font-size: 0.8rem;
      padding: 0;
      line-height: 1;
      opacity: 0.5;
      margin-left: 1px;
    }

    .list-filter-tag button:hover {
      opacity: 1;
    }

    .list-no-results {
      padding: 40px 20px;
      text-align: center;
    }

    .list-no-results-text {
      color: var(--text-muted);
      font-size: 0.9rem;
      margin-bottom: 12px;
    }

    .list-no-results-clear {
      font-size: 0.8rem;
      padding: 6px 14px;
      background: var(--surface-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .list-no-results-clear:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .list-items {
      padding: 12px;
    }

    .list-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--surface-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 6px;
      cursor: grab;
      transition: all 0.2s ease;
      animation: fadeInItem 0.3s ease;
    }

    @keyframes fadeInItem {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .list-item:last-child {
      margin-bottom: 0;
    }

    .list-item:hover {
      border-color: var(--border-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
      background: linear-gradient(to right, var(--surface-elevated), rgba(255,255,255,0.8));
    }

    .list-item.selected {
      border-color: var(--accent);
      box-shadow: var(--shadow-md);
    }

    .list-item.completed .title-text {
      color: var(--text-muted);
    }

    .list-item.completed .title-text > a,
    .list-item.completed .title-text:not(:has(a))::before {
      text-decoration: line-through;
      text-decoration-color: var(--text-muted);
    }

    .list-item.completing .title-text {
      animation: strikethrough 0.3s ease forwards;
    }

    @keyframes strikethrough {
      0% {
        color: var(--text-primary);
      }
      100% {
        color: var(--text-muted);
      }
    }

    .list-item.dragging {
      opacity: 0.5;
      transform: rotate(1deg);
    }

    .list-item .drag-handle {
      display: grid;
      grid-template-columns: repeat(2, 4px);
      gap: 3px;
      padding: 4px 2px;
      cursor: grab;
      flex-shrink: 0;
      opacity: 0.4;
      transition: opacity 0.2s ease;
    }

    .list-item:hover .drag-handle {
      opacity: 0.7;
    }

    .list-item .drag-handle:active {
      cursor: grabbing;
    }

    .drag-handle-dot {
      width: 4px;
      height: 4px;
      background: var(--text-muted);
      border-radius: 50%;
    }

    .list-checkbox {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border-hover);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.2s ease;
    }

    .list-checkbox:hover {
      border-color: var(--accent);
      background: rgba(192, 104, 66, 0.1);
    }

    .list-checkbox.checked {
      background: var(--accent);
      border-color: var(--accent);
      animation: checkboxPop 0.2s ease;
    }

    @keyframes checkboxPop {
      0% { transform: scale(1); }
      50% { transform: scale(1.15); }
      100% { transform: scale(1); }
    }

    .list-checkbox.checked svg {
      stroke: white;
      animation: checkmark 0.25s ease forwards;
    }

    @keyframes checkmark {
      0% {
        stroke-dashoffset: 20;
        opacity: 0;
      }
      100% {
        stroke-dashoffset: 0;
        opacity: 1;
      }
    }

    .list-checkbox svg {
      width: 12px;
      height: 12px;
      stroke: transparent;
      stroke-width: 2.5;
      fill: none;
      stroke-dasharray: 20;
      stroke-dashoffset: 0;
    }

    .list-favicon-wrapper {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
    }

    .list-favicon-wrapper:active {
      cursor: grabbing;
    }

    .list-favicon {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      background: var(--surface);
    }

    .list-favicon-placeholder {
      width: 16px;
      height: 16px;
      color: var(--text-muted);
    }

    .no-url-indicator {
      font-size: 0.7rem;
      color: var(--text-muted);
      background: var(--surface);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 8px;
    }

    .list-link {
      flex: 1;
      color: var(--text-primary);
      text-decoration: none;
      font-size: 0.9rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      transition: color 0.2s ease;
    }

    .list-link:hover {
      color: var(--accent);
    }

    .list-item-title {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
      overflow: hidden;
    }

    .list-item-title .title-text {
      color: var(--text-primary);
      font-size: 0.9rem;
      font-weight: 500;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      line-height: 1.4;
      cursor: grab;
    }

    .list-item-title .title-text:active {
      cursor: grabbing;
    }

    .list-item-title .title-text a {
      color: inherit;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .list-item-title .title-text a:hover {
      color: var(--accent);
    }

    .list-item-title .url-text {
      color: var(--text-muted);
      font-size: 0.75rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .list-item-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .list-item:hover .list-item-actions {
      opacity: 1;
    }

    .list-item-btn {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      width: 30px;
      height: 30px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .list-item-btn svg {
      width: 16px;
      height: 16px;
    }

    .list-item-btn:hover {
      background: var(--surface-elevated);
      border-color: var(--border-hover);
      color: var(--text-primary);
    }

    .list-item-btn.delete:hover {
      color: var(--danger);
      border-color: var(--danger);
    }

    .list-item-btn.edit:hover {
      color: var(--accent);
      border-color: var(--accent);
    }

    .list-empty {
      padding: 60px 24px;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .list-empty-icon {
      width: 64px;
      height: 64px;
      margin: 0 auto 16px;
      color: var(--border-hover);
    }

    .list-empty-text {
      margin-bottom: 8px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .list-empty-hint {
      font-size: 0.85rem;
    }

    .list-items-container.drag-over {
      background: rgba(192, 104, 66, 0.05);
    }

    /* Completed Section */
    .list-completed-section {
      margin-top: 16px;
      position: relative;
    }

    .list-completed-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 16px;
      right: 16px;
      height: 1px;
      background: linear-gradient(to right, transparent, var(--border), transparent);
    }

    .list-completed-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 14px 16px 10px;
      cursor: pointer;
      color: var(--text-muted);
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.2s ease;
      user-select: none;
      letter-spacing: 0.02em;
    }

    .list-completed-header:hover {
      color: var(--text-secondary);
    }

    .list-completed-header svg {
      width: 16px;
      height: 16px;
      transition: transform 0.2s ease;
    }

    .list-completed-header.collapsed svg {
      transform: rotate(-90deg);
    }

    .list-completed-count {
      color: var(--text-muted);
      font-weight: 400;
    }

    .list-completed-items {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .list-completed-items.collapsed {
      max-height: 0 !important;
    }

    .list-date-group-header {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      padding: 12px 16px 6px;
      margin-top: 4px;
    }

    .list-date-group-header:first-child {
      margin-top: 0;
      padding-top: 8px;
    }

    .list-item.completed {
      opacity: 0.7;
    }

    .list-item.completed:hover {
      opacity: 1;
    }

    .list-item .completed-time {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .list-item-tags {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-left: 8px;
    }

    .list-item-tag {
      font-size: 0.65rem;
      padding: 1px 6px;
      color: #5a5a5a;
      border-radius: 8px;
      font-weight: 500;
    }

    .list-item-notes {
      color: var(--text-muted);
      font-size: 0.8rem;
      font-weight: 400;
      margin-left: 6px;
      font-style: italic;
    }

    .list-item-notes::before {
      content: '‚Äî';
      margin-right: 6px;
      opacity: 0.5;
    }

    /* List Modal */
    .list-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(45, 42, 38, 0.6);
      backdrop-filter: blur(4px);
      z-index: 1000;
    }

    .list-modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--surface-elevated);
      padding: 28px;
      border-radius: 16px;
      width: 90%;
      max-width: 450px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-lg);
    }

    .list-modal-content h3 {
      margin: 0 0 20px 0;
      color: var(--text-primary);
      font-weight: 600;
      font-size: 1.1rem;
    }

    .list-modal-content .form-group {
      margin-bottom: 16px;
    }

    .list-modal-content .form-group:last-of-type {
      margin-bottom: 20px;
    }

    .list-modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="title-container">
      <h1 id="app-title">Tobi's Task Manager</h1>
      <button class="title-edit-btn" id="title-edit-btn" onclick="toggleTitleEdit()">Edit</button>
    </div>

    <nav class="view-nav">
      <button class="view-nav-btn active" data-view="kanban" onclick="switchView('kanban')">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <rect x="1" y="1" width="4" height="14" rx="1"/>
          <rect x="6" y="1" width="4" height="9" rx="1"/>
          <rect x="11" y="1" width="4" height="6" rx="1"/>
        </svg>
        Kanban Board
      </button>
      <button class="view-nav-btn" data-view="list" onclick="switchView('list')">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <line x1="1" y1="3" x2="15" y2="3"/>
          <line x1="1" y1="8" x2="15" y2="8"/>
          <line x1="1" y1="13" x2="15" y2="13"/>
        </svg>
        Simple List
      </button>
    </nav>

    <div class="board" id="board">
      <div class="column" data-column="todo">
        <div class="column-header todo" onclick="toggleColumn('todo')">To Do</div>
        <div class="tasks-container" id="todo-tasks"></div>
        <div class="add-task-btn" onclick="openTaskModal('todo')">
          + Add Task
        </div>
      </div>

      <div class="column" data-column="in-progress">
        <div class="column-header in-progress" onclick="toggleColumn('in-progress')">In Progress</div>
        <div class="tasks-container" id="in-progress-tasks"></div>
        <div class="add-task-btn" onclick="openTaskModal('in-progress')">
          + Add Task
        </div>
      </div>

      <div class="column" data-column="done">
        <div class="column-header done" onclick="toggleColumn('done')">Done</div>
        <div class="tasks-container" id="done-tasks"></div>
        <div class="add-task-btn" onclick="openTaskModal('done')">
          + Add Task
        </div>
      </div>
    </div>

    <div class="list-view" id="list-view" style="display: none;">
      <div class="list-container">
        <div class="list-header">
          <div class="list-header-left">
            <h2>My Tasks</h2>
            <span class="list-count" id="list-count"></span>
          </div>
          <button class="add-list-item-btn" onclick="openListModal()">
            <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
              <line x1="8" y1="3" x2="8" y2="13"/>
              <line x1="3" y1="8" x2="13" y2="8"/>
            </svg>
            Add Task
          </button>
        </div>
        <div class="list-filter-bar" id="list-filter-bar" style="display: none;">
          <div class="list-filter-multiselect" id="list-filter-multiselect">
            <div class="list-filter-trigger" id="list-filter-trigger" onclick="toggleFilterDropdown()">
              <span class="list-filter-placeholder" id="list-filter-placeholder">Filter by tags...</span>
              <div class="list-filter-selected" id="list-filter-selected"></div>
              <svg class="list-filter-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
              </svg>
            </div>
            <div class="list-filter-dropdown" id="list-filter-dropdown">
              <div class="list-filter-options" id="list-filter-options"></div>
            </div>
          </div>
        </div>
        <div class="list-items" id="list-items"></div>
        <div class="list-empty" id="list-empty">
          <svg class="list-empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
            <rect x="9" y="3" width="6" height="4" rx="1"/>
            <line x1="9" y1="12" x2="15" y2="12"/>
            <line x1="9" y1="16" x2="13" y2="16"/>
          </svg>
          <div class="list-empty-text">No tasks yet</div>
          <div class="list-empty-hint">Click "Add Task" or press <kbd>N</kbd> to get started</div>
        </div>
      </div>
    </div>
  </div>

  <div class="list-modal" id="list-modal">
    <div class="list-modal-content">
      <h3 id="list-modal-title">Add Task</h3>
      <div class="form-group">
        <label for="list-item-title">Title</label>
        <input type="text" id="list-item-title" placeholder="Enter a title for this task" required>
      </div>
      <div class="form-group">
        <label for="list-item-url">URL (optional)</label>
        <input type="url" id="list-item-url" placeholder="https://example.com">
      </div>
      <div class="form-group">
        <label>Tags</label>
        <div class="tags-input" id="list-tags-input">
          <input type="text" id="list-tag-input" placeholder="Add tag...">
        </div>
        <div class="tag-suggestions" id="list-tag-suggestions"></div>
      </div>
      <div class="form-group">
        <label for="list-item-notes">Notes (optional)</label>
        <textarea id="list-item-notes" placeholder="Add any notes..." rows="3"></textarea>
      </div>
      <div class="list-modal-actions">
        <button class="btn btn-secondary" onclick="closeListModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveListItem()">Save</button>
      </div>
    </div>
  </div>

  <div class="modal" id="task-modal">
    <div class="modal-content">
      <h3 id="modal-title">Add Task</h3>
      <div class="form-group">
        <label for="task-title">Title</label>
        <input type="text" id="task-title" placeholder="Enter task title">
      </div>
      <div class="form-group">
        <label for="task-url">URL (optional)</label>
        <input type="url" id="task-url" placeholder="https://example.com">
      </div>
      <div class="form-group">
        <label for="task-tags">Tags (optional)</label>
        <div class="tags-input" id="tags-input">
          <input type="text" class="tag-input" id="tag-input" placeholder="Type and press Enter to add tags">
        </div>
      </div>
      <div class="form-group">
        <label for="task-notes">Notes (optional)</label>
        <textarea id="task-notes" placeholder="Add any additional notes..."></textarea>
      </div>
      <div class="form-group">
        <label for="task-started">Started At (optional)</label>
        <input type="datetime-local" id="task-started" placeholder="When did you start working on this?">
      </div>
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="closeTaskModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveTask()">Save</button>
      </div>
    </div>
  </div>

  <div class="sync-indicator" id="sync-indicator">Loading...</div>

  <button class="help-button" onclick="openInstructionsModal()" title="Help & Instructions">?</button>

  <div class="instructions-modal" id="instructions-modal">
    <div class="instructions-content">
      <button class="instructions-close" onclick="closeInstructionsModal()">‚úï</button>

      <!-- Kanban Board Instructions -->
      <div id="kanban-instructions">
        <h2>Kanban Board Instructions</h2>

        <h3>‚ú® Getting Started</h3>
        <ul>
          <li>Create tasks by clicking "+ Add Task" or pressing <kbd>N</kbd></li>
          <li>Drag and drop tasks between columns to change their status</li>
          <li>Paste URLs directly with <kbd>Cmd+V</kbd> / <kbd>Ctrl+V</kbd> to create tasks</li>
        </ul>

        <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
        <ul>
          <li><kbd>N</kbd> - Create new task in To Do column</li>
          <li><kbd>Arrow Keys</kbd> - Navigate between tasks</li>
          <li><kbd>Shift + Arrow Keys</kbd> - Move task up/down or to different columns</li>
          <li><kbd>Enter</kbd> - Edit selected task</li>
          <li><kbd>Delete</kbd> / <kbd>Backspace</kbd> - Delete selected task</li>
          <li><kbd>Cmd+V</kbd> / <kbd>Ctrl+V</kbd> - Paste URL to create task</li>
        </ul>

        <h3>üéØ Focus & Pomodoro Timer</h3>
        <ul>
          <li>Click the üéØ button to mark a task as actively being worked on</li>
          <li>Timer starts automatically and counts your focus time</li>
          <li>Earn a üçÖ tomato for every 25 minutes of accumulated focus time</li>
          <li>Click ‚ö™ button to deactivate focus (timer pauses but time is saved)</li>
          <li>Only one task can be active at a time</li>
        </ul>

        <h3>üìã Task Actions</h3>
        <p>Hover over any task to see action buttons:</p>
        <ul>
          <li>üéØ / ‚ö™ - Mark as actively working / Stop focus</li>
          <li>‚è∏Ô∏è - Put task on hold (pauses work without deleting)</li>
          <li>‚úèÔ∏è - Edit task details</li>
          <li>üìã - Duplicate task</li>
          <li>üóëÔ∏è - Delete task</li>
        </ul>

        <h3>üè∑Ô∏è Tags & Organization</h3>
        <ul>
          <li>Add tags to categorize tasks (type and press Enter)</li>
          <li>Tag suggestions appear based on previously used tags</li>
          <li>Remove tags by clicking the √ó button</li>
        </ul>

        <h3>‚è± Time Tracking</h3>
        <ul>
          <li>Set a "Started At" time when creating or editing tasks</li>
          <li>Click the start time to edit it later</li>
          <li>Completed tasks show total duration</li>
          <li>Focus timer tracks active work time separately</li>
        </ul>

        <h3>üìä Column Management</h3>
        <ul>
          <li>Click column headers to collapse/expand them</li>
          <li>Done tasks are automatically grouped by completion date</li>
          <li>Task order is maintained within To Do and In Progress columns</li>
        </ul>

        <h3>üíæ Data & Sync</h3>
        <ul>
          <li>All data is saved automatically to localStorage</li>
          <li>If using server mode, data syncs to tasks.json</li>
          <li>Sync status shown in bottom-left corner</li>
          <li>Customize the app title by clicking "Edit" next to the header</li>
        </ul>
      </div>

      <!-- Simple List Instructions -->
      <div id="list-instructions" style="display: none;">
        <h2>Simple List Instructions</h2>

        <h3>‚ú® Getting Started</h3>
        <ul>
          <li>Add tasks by clicking "+ Add Task" or pressing <kbd>N</kbd></li>
          <li>Each task has a URL that opens in a new tab when clicked</li>
          <li>Drag and drop tasks to reorder them</li>
        </ul>

        <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
        <ul>
          <li><kbd>N</kbd> - Add new task</li>
          <li><kbd>‚Üë</kbd> / <kbd>‚Üì</kbd> - Navigate between tasks</li>
          <li><kbd>Enter</kbd> - Open selected task's URL in new tab</li>
          <li><kbd>E</kbd> - Edit selected task</li>
          <li><kbd>Delete</kbd> / <kbd>Backspace</kbd> - Delete selected task</li>
        </ul>

        <h3>üìã Task Actions</h3>
        <p>Hover over any task to see action buttons:</p>
        <ul>
          <li>‚úèÔ∏è - Edit task title and URL</li>
          <li>üóëÔ∏è - Delete task</li>
        </ul>

        <h3>üîó URLs & Favicons</h3>
        <ul>
          <li>URL is optional - add one to make the task clickable</li>
          <li>Favicons are automatically fetched from the URL</li>
          <li>Click the task title to open the URL in a new tab</li>
          <li>Paste a URL with <kbd>Cmd+V</kbd> / <kbd>Ctrl+V</kbd> to quickly add a task</li>
        </ul>

        <h3>üíæ Data Storage</h3>
        <ul>
          <li>Simple List has its own separate task data</li>
          <li>Data is saved automatically to localStorage</li>
          <li>Tasks persist between sessions</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    let tasks = [];
    let selectedTaskId = null;
    let currentEditingTask = null;
    let currentColumn = 'todo';
    let currentTags = [];
    let collapsedColumns = new Set();
    let selectedColumn = 0; // 0=todo, 1=in-progress, 2=done
    const columnNames = ['todo', 'in-progress', 'done'];
    let allTags = new Set();
    let tagSuggestions = [];
    let isServerMode = window.location.protocol !== 'file:';
    let lastSavedTime = null;

    // Simple List state
    let listItems = [];
    let selectedListItemId = null;
    let currentEditingListItem = null;
    let currentView = localStorage.getItem('taskManager_currentView') || 'kanban';
    let currentListTags = [];
    let allListTags = new Set();
    let activeTagFilters = new Set();

    // Clean up old time tracking data
    function migrateTimeTrackingData(task) {
      // Remove old time tracking fields
      if (task.timeEntries) delete task.timeEntries;
      if (task.isTracking) delete task.isTracking;
      if (task.trackingStartedAt) delete task.trackingStartedAt;
      if (task.totalTime) delete task.totalTime;

      return task;
    }

    // Load tasks from server or localStorage
    async function loadTasks() {
      if (isServerMode) {
        try {
          const response = await fetch('/tasks.json');
          if (response.ok) {
            const serverTasks = await response.json();
            tasks = serverTasks.map(migrateTimeTrackingData);
            collectAllTags();
            renderTasks();
            // Also sync to localStorage as backup
            localStorage.setItem('taskManager_tasks', JSON.stringify(tasks));
            return;
          }
        } catch (error) {
          console.log('Could not load from server, falling back to localStorage');
        }
      }

      // Fallback to localStorage
      const savedTasks = localStorage.getItem('taskManager_tasks');
      if (savedTasks) {
        tasks = JSON.parse(savedTasks).map(migrateTimeTrackingData);
        collectAllTags();
        renderTasks();
      }
    }

    // Collect all unique tags from tasks
    function collectAllTags() {
      allTags.clear();
      tasks.forEach(task => {
        if (task.tags) {
          task.tags.forEach(tag => allTags.add(tag));
        }
      });
    }

    // Save tasks to localStorage and server
    async function saveTasks() {
      localStorage.setItem('taskManager_tasks', JSON.stringify(tasks));
      collectAllTags();

      // Save to server if in server mode
      if (isServerMode) {
        try {
          const response = await fetch('/save-tasks', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(tasks)
          });

          if (response.ok) {
            updateSyncStatus('synced');
          } else {
            updateSyncStatus('error');
          }
        } catch (error) {
          updateSyncStatus('error');
        }
      } else {
        updateSyncStatus('synced');
      }
    }

    // Format timestamp for display
    function formatLastSaved(timestamp) {
      if (!timestamp) return '';

      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);

      if (diffMins < 1) return 'just now';
      if (diffMins === 1) return '1 min ago';
      if (diffMins < 60) return `${diffMins} mins ago`;

      const diffHours = Math.floor(diffMins / 60);
      if (diffHours === 1) return '1 hour ago';
      if (diffHours < 24) return `${diffHours} hours ago`;

      // Show actual time for older saves
      return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
    }

    // Time tracking utility functions
    function formatTime(milliseconds) {
      if (!milliseconds || milliseconds < 0) return '0m';

      const seconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) {
        const remainingHours = hours % 24;
        if (remainingHours > 0) {
          return `${days}d ${remainingHours}h`;
        }
        return `${days}d`;
      } else if (hours > 0) {
        const remainingMinutes = minutes % 60;
        if (remainingMinutes > 0) {
          return `${hours}h ${remainingMinutes}m`;
        }
        return `${hours}h`;
      } else if (minutes > 0) {
        return `${minutes}m`;
      } else {
        return `${seconds}s`;
      }
    }

    function calculateTaskDuration(task) {
      // Only calculate duration for tasks that have both start and completion time
      if (!task.startedAt || !task.completedAt) return 0;

      const start = new Date(task.startedAt).getTime();
      const end = new Date(task.completedAt).getTime();

      return end - start;
    }

    function formatDateTime(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
    }

    // Update sync status indicator
    function updateSyncStatus(status) {
      const indicator = document.getElementById('sync-indicator');
      if (!indicator) return;

      indicator.className = 'sync-indicator';

      if (status === 'synced') {
        lastSavedTime = new Date();
        indicator.classList.add('synced');
        indicator.textContent = `‚úì Saved ${formatLastSaved(lastSavedTime)}`;
        localStorage.setItem('taskManager_lastSaved', lastSavedTime.toISOString());
      } else if (status === 'error') {
        indicator.classList.add('error');
        if (lastSavedTime) {
          indicator.textContent = `‚ö† Last saved ${formatLastSaved(lastSavedTime)} (local only)`;
        } else {
          indicator.textContent = '‚ö† Not synced (local only)';
        }
      }
    }

    // Update the "time ago" text periodically
    function refreshSyncTimestamp() {
      if (lastSavedTime) {
        const indicator = document.getElementById('sync-indicator');
        if (indicator && indicator.classList.contains('synced')) {
          indicator.textContent = `‚úì Saved ${formatLastSaved(lastSavedTime)}`;
        }
      }
    }

    // Generate unique ID
    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Render all tasks
    function renderTasks() {
      const columns = ['todo', 'in-progress', 'done'];

      columns.forEach(column => {
        const container = document.getElementById(`${column}-tasks`);
        container.innerHTML = '';

        let columnTasks = tasks.filter(task => task.column === column);

        if (column === 'done') {
          // Group done tasks by completion date
          const tasksByDate = groupTasksByDate(columnTasks);

          Object.keys(tasksByDate)
            .sort((a, b) => new Date(b) - new Date(a)) // Sort dates descending
            .forEach(date => {
              const dateGroup = document.createElement('div');
              dateGroup.className = 'date-group';

              const dateHeader = document.createElement('div');
              dateHeader.className = 'date-header';
              dateHeader.textContent = formatDateHeader(date);
              dateGroup.appendChild(dateHeader);

              // Sort tasks within date by completion time (descending)
              tasksByDate[date]
                .sort((a, b) => new Date(b.completedAt || b.createdAt) - new Date(a.completedAt || a.createdAt))
                .forEach(task => {
                  const taskElement = createTaskElement(task, tasks.indexOf(task));
                  dateGroup.appendChild(taskElement);
                });

              container.appendChild(dateGroup);
            });
        } else {
          // Sort by order field for todo and in-progress columns
          columnTasks.sort((a, b) => (a.order || 0) - (b.order || 0));
          columnTasks.forEach((task, index) => {
            const taskElement = createTaskElement(task, tasks.indexOf(task));
            container.appendChild(taskElement);
          });
        }

      });
    }

    // Update task order within column based on DOM order
    function updateTaskOrder(container, column) {
      const taskElements = [...container.querySelectorAll('.task')];
      taskElements.forEach((element, index) => {
        const elementTaskId = element.dataset.taskId;
        const task = tasks.find(t => t.id === elementTaskId);
        if (task) {
          task.order = index;
        }
      });
    }

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.task:not(.dragging)')];

      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;

        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Group tasks by date
    function groupTasksByDate(tasks) {
      const groups = {};
      tasks.forEach(task => {
        const date = task.completedAt ?
          new Date(task.completedAt).toDateString() :
          new Date(task.createdAt).toDateString();

        if (!groups[date]) {
          groups[date] = [];
        }
        groups[date].push(task);
      });
      return groups;
    }

    // Format date header
    function formatDateHeader(dateString) {
      const date = new Date(dateString);
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);

      if (date.toDateString() === today.toDateString()) {
        return 'Today';
      } else if (date.toDateString() === yesterday.toDateString()) {
        return 'Yesterday';
      } else {
        return date.toLocaleDateString('en-US', {
          weekday: 'long',
          month: 'short',
          day: 'numeric'
        });
      }
    }

    // Toggle column collapse
    function toggleColumn(columnName) {
      const column = document.querySelector(`[data-column="${columnName}"]`);
      if (collapsedColumns.has(columnName)) {
        collapsedColumns.delete(columnName);
        column.classList.remove('collapsed');
      } else {
        collapsedColumns.add(columnName);
        column.classList.add('collapsed');
      }
      localStorage.setItem('taskManager_collapsedColumns', JSON.stringify([...collapsedColumns]));
    }

    // Load collapsed state
    function loadCollapsedState() {
      const saved = localStorage.getItem('taskManager_collapsedColumns');
      if (saved) {
        collapsedColumns = new Set(JSON.parse(saved));
        collapsedColumns.forEach(columnName => {
          const column = document.querySelector(`[data-column="${columnName}"]`);
          if (column) column.classList.add('collapsed');
        });
      }
    }

    // Create task element
    function createTaskElement(task, index) {
      const taskDiv = document.createElement('div');
      taskDiv.className = 'task';
      taskDiv.draggable = true;
      taskDiv.dataset.taskId = task.id;
      taskDiv.dataset.index = index;

      const isDone = task.column === 'done';
      const duration = calculateTaskDuration(task);

      // Build time info HTML
      let timeInfoHTML = '';
      if (task.startedAt) {
        const startTimeDisplay = formatDateTime(task.startedAt);
        timeInfoHTML = `
          <div class="task-time-info">
            <span class="time-started" onclick="editStartTime(event, '${task.id}')" title="Click to edit start time">
              üìÖ Started: ${startTimeDisplay}
            </span>
          </div>
        `;
      }

      // For done tasks, show duration
      if (isDone && duration > 0) {
        timeInfoHTML += `
          <div class="task-total-time">
            <span class="time-icon">‚è±</span>
            <span>Completed in ${formatTime(duration)}</span>
          </div>
        `;
      }

      // Build focus timer HTML (show for all tasks except Done)
      let focusTimerHTML = '';
      if (!isDone) {
        const focusTime = getCurrentFocusTime(task);
        const tomatoCount = getTomatoCount(focusTime);
        const tomatoes = formatTomatoes(tomatoCount);

        // Show timer if there's accumulated time OR if task is currently active
        if (focusTime > 0 || task.isActive) {
          focusTimerHTML = `
            <div class="task-focus-timer" data-task-id="${task.id}">
              <div class="focus-timer-display">‚è± ${formatFocusTime(focusTime)}</div>
              ${tomatoes ? `<div class="task-tomatoes">${tomatoes}</div>` : ''}
            </div>
          `;
        }
      } else {
        // For done tasks, only show tomatoes if they exist
        const focusTime = task.accumulatedFocusTime || 0;
        const tomatoCount = getTomatoCount(focusTime);
        const tomatoes = formatTomatoes(tomatoCount);

        if (tomatoes) {
          focusTimerHTML = `
            <div class="task-focus-timer" data-task-id="${task.id}">
              <div class="task-tomatoes">${tomatoes}</div>
            </div>
          `;
        }
      }

      taskDiv.innerHTML = `
                <div class="task-actions">
                    <button class="action-btn active-btn ${task.isActive ? 'is-active' : ''}" onclick="toggleActive('${task.id}')" title="${task.isActive ? 'Mark as not active' : 'Mark as actively working'}">${task.isActive ? '‚ö™' : 'üéØ'}</button>
                    <button class="action-btn hold" onclick="toggleHold('${task.id}')" title="${task.onHold ? 'Resume' : 'Put on Hold'}">${task.onHold ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'}</button>
                    <button class="action-btn edit" onclick="editTaskByIdFromButton('${task.id}')" title="Edit">‚úèÔ∏è</button>
                    <button class="action-btn duplicate" onclick="duplicateTaskByIdFromButton('${task.id}')" title="Duplicate">üìã</button>
                    <button class="action-btn delete" onclick="deleteTaskByIdFromButton('${task.id}')" title="Delete">üóëÔ∏è</button>
                </div>
                <div class="task-title">${task.title}</div>
                ${task.url ? `<div class="task-url-container"><img src="${getFaviconUrl(task.url)}" class="task-favicon" onerror="this.style.display='none'"><a href="${task.url}" target="_blank" class="task-url">${task.url}</a></div>` : ''}
                ${task.tags && task.tags.length > 0 ? `<div class="task-tags">${task.tags.map(tag => `<span class="task-tag">${tag}</span>`).join('')}</div>` : ''}
                ${task.notes ? `<div class="task-notes">${escapeHtml(task.notes)}</div>` : ''}
                ${timeInfoHTML}
                ${focusTimerHTML}
            `;

      // Add on-hold class if task is on hold
      if (task.onHold) {
        taskDiv.classList.add('on-hold');
      }

      // Add active class if task is active
      if (task.isActive) {
        taskDiv.classList.add('active');
      }

      // Drag events (all tasks are draggable)
      taskDiv.addEventListener('dragstart', handleDragStart);
      taskDiv.addEventListener('dragend', handleDragEnd);

      // Click events
      taskDiv.addEventListener('click', () => selectTask(task.id));
      taskDiv.addEventListener('dblclick', () => editTaskByIdFromButton(task.id));

      return taskDiv;
    }

    // Drag and drop functionality
    function handleDragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.taskId);
      e.target.classList.add('dragging');
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
    }

    // Set up drop zones after DOM is loaded
    function setupDropZones() {
      document.querySelectorAll('.tasks-container').forEach(container => {
        container.addEventListener('dragover', handleDragOver);
        container.addEventListener('drop', handleDrop);
        container.addEventListener('dragenter', handleDragEnter);
        container.addEventListener('dragleave', handleDragLeave);
      });
    }

    function handleDragOver(e) {
      e.preventDefault();

      const dragging = document.querySelector('.dragging');
      if (!dragging) return;

      const container = e.currentTarget;
      const newColumn = container.id.replace('-tasks', '');
      const draggingTaskId = dragging.dataset.taskId;
      const draggingTask = tasks.find(t => t.id === draggingTaskId);

      if (!draggingTask) return;

      // If dragging within the same column and it's not Done, allow reordering
      if (draggingTask.column === newColumn && newColumn !== 'done') {
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement == null) {
          container.appendChild(dragging);
        } else {
          container.insertBefore(dragging, afterElement);
        }
      }
    }

    function handleDragEnter(e) {
      e.preventDefault();
      e.currentTarget.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      if (!e.currentTarget.contains(e.relatedTarget)) {
        e.currentTarget.classList.remove('drag-over');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');

      const taskId = e.dataTransfer.getData('text/plain');
      const newColumn = e.currentTarget.id.replace('-tasks', '');
      const dragging = document.querySelector('.dragging');

      const taskIndex = tasks.findIndex(task => task.id === taskId);
      if (taskIndex !== -1) {
        const oldColumn = tasks[taskIndex].column;

        // Check if we're moving between columns or reordering within column
        if (oldColumn !== newColumn) {
          // Moving between columns
          tasks[taskIndex].column = newColumn;

          // If moving to done, set completion timestamp and reset focus timer
          if (newColumn === 'done' && oldColumn !== 'done') {
            tasks[taskIndex].completedAt = new Date().toISOString();
            // Stop focus timer and reset accumulated time (keep tomatoes via accumulatedFocusTime)
            if (tasks[taskIndex].focusStartTime) {
              const elapsed = Date.now() - new Date(tasks[taskIndex].focusStartTime).getTime();
              tasks[taskIndex].accumulatedFocusTime = (tasks[taskIndex].accumulatedFocusTime || 0) + elapsed;
            }
            delete tasks[taskIndex].focusStartTime;
            tasks[taskIndex].isActive = false;
          } else if (oldColumn === 'done' && newColumn !== 'done') {
            // If moving out of done, remove completion timestamp and reset focus timer
            delete tasks[taskIndex].completedAt;
            // Reset accumulated time but keep the task's tomato count in the data
            // (tomatoes are still visible but timer starts fresh)
            delete tasks[taskIndex].focusStartTime;
            tasks[taskIndex].accumulatedFocusTime = 0;
            tasks[taskIndex].isActive = false;
          }

          // Reset order when moving between columns
          const columnTasks = tasks.filter(task => task.column === newColumn && task.id !== taskId);
          tasks[taskIndex].order = columnTasks.length;
        } else {
          // Reordering within same column (only allowed for todo and in-progress)
          if (newColumn !== 'done') {
            updateTaskOrder(e.currentTarget, newColumn);
          }
        }

        saveTasks();
        renderTasks();
      }
    }

    // Task modal functions
    function openTaskModal(column = 'todo') {
      currentColumn = column;
      currentEditingTask = null;
      currentTags = [];
      document.getElementById('modal-title').textContent = 'Add Task';
      document.getElementById('task-title').value = '';
      document.getElementById('task-url').value = '';
      document.getElementById('task-notes').value = '';
      document.getElementById('task-started').value = '';
      renderTagsInput();
      document.getElementById('task-modal').style.display = 'block';
      document.getElementById('task-title').focus();
    }

    function closeTaskModal() {
      document.getElementById('task-modal').style.display = 'none';
    }

    // Instructions modal functions
    function openInstructionsModal() {
      // Show the appropriate instructions based on current view
      const kanbanInstructions = document.getElementById('kanban-instructions');
      const listInstructions = document.getElementById('list-instructions');

      if (currentView === 'list') {
        kanbanInstructions.style.display = 'none';
        listInstructions.style.display = 'block';
      } else {
        kanbanInstructions.style.display = 'block';
        listInstructions.style.display = 'none';
      }

      document.getElementById('instructions-modal').style.display = 'block';
    }

    function closeInstructionsModal() {
      document.getElementById('instructions-modal').style.display = 'none';
    }

    function editTask(index) {
      const task = tasks[index];
      currentEditingTask = index;
      currentColumn = task.column;
      currentTags = task.tags ? [...task.tags] : [];
      document.getElementById('modal-title').textContent = 'Edit Task';
      document.getElementById('task-title').value = task.title;
      document.getElementById('task-url').value = task.url || '';
      document.getElementById('task-notes').value = task.notes || '';

      // Set started time if it exists
      if (task.startedAt) {
        const date = new Date(task.startedAt);
        const localDateTime = new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
        document.getElementById('task-started').value = localDateTime;
      } else {
        document.getElementById('task-started').value = '';
      }

      renderTagsInput();
      document.getElementById('task-modal').style.display = 'block';
      document.getElementById('task-title').focus();
    }

    function deleteTask(index) {
      if (confirm('Are you sure you want to delete this task?')) {
        tasks.splice(index, 1);
        saveTasks();
        renderTasks();
      }
    }

    // Helper functions for button clicks that use task IDs
    function editTaskByIdFromButton(taskId) {
      const taskIndex = tasks.findIndex(t => t.id === taskId);
      if (taskIndex >= 0) {
        editTask(taskIndex);
      }
    }

    function deleteTaskByIdFromButton(taskId) {
      const taskIndex = tasks.findIndex(t => t.id === taskId);
      if (taskIndex >= 0) {
        // Clear selection if deleting selected task
        if (selectedTaskId === taskId) {
          selectedTaskId = null;
        }
        deleteTask(taskIndex);
      }
    }

    function duplicateTaskByIdFromButton(taskId) {
      const taskIndex = tasks.findIndex(t => t.id === taskId);
      if (taskIndex >= 0) {
        duplicateTask(taskIndex);
      }
    }

    function duplicateTask(index) {
      const originalTask = tasks[index];

      // Increment order of all existing tasks in the same column
      tasks.forEach(task => {
        if (task.column === originalTask.column) {
          task.order = (task.order || 0) + 1;
        }
      });

      // Create duplicate task
      const duplicatedTask = {
        id: generateId(),
        title: originalTask.title,
        url: originalTask.url || '',
        notes: originalTask.notes || '',
        tags: originalTask.tags ? [...originalTask.tags] : [],
        column: originalTask.column,
        order: 0,
        createdAt: new Date().toISOString(),
        onHold: originalTask.onHold || false
      };

      // Remove completedAt and startedAt for duplicated task
      // (they are not copied, so they won't exist in the new task)

      tasks.push(duplicatedTask);
      saveTasks();
      renderTasks();

      // Select the newly duplicated task
      selectTask(duplicatedTask.id);
    }

    function saveTask() {
      const title = document.getElementById('task-title').value.trim();
      const url = document.getElementById('task-url').value.trim();
      const notes = document.getElementById('task-notes').value.trim();
      const startedValue = document.getElementById('task-started').value;

      if (!title) {
        alert('Please enter a task title');
        return;
      }

      // Convert local datetime to ISO string
      const startedAt = startedValue ? new Date(startedValue).toISOString() : null;

      if (currentEditingTask !== null) {
        // Edit existing task
        tasks[currentEditingTask].title = title;
        tasks[currentEditingTask].url = url;
        tasks[currentEditingTask].notes = notes;
        tasks[currentEditingTask].tags = currentTags;
        if (startedAt) {
          tasks[currentEditingTask].startedAt = startedAt;
        } else {
          delete tasks[currentEditingTask].startedAt;
        }
      } else {
        // Create new task at the top (order 0)
        // First, increment the order of all existing tasks in this column
        tasks.forEach(task => {
          if (task.column === currentColumn) {
            task.order = (task.order || 0) + 1;
          }
        });

        const task = {
          id: generateId(),
          title: title,
          url: url,
          notes: notes,
          tags: currentTags,
          column: currentColumn,
          order: 0,
          createdAt: new Date().toISOString()
        };

        if (startedAt) {
          task.startedAt = startedAt;
        }

        tasks.push(task);
      }

      saveTasks();
      renderTasks();
      closeTaskModal();
    }

    // Task selection for navigation
    function selectTask(taskId) {
      // Remove previous selection
      document.querySelectorAll('.task.selected').forEach(task => {
        task.classList.remove('selected');
      });

      selectedTaskId = taskId;
      const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
      if (taskElement) {
        taskElement.classList.add('selected');
        taskElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

        // Update selected column based on task location
        const task = tasks.find(t => t.id === taskId);
        if (task) {
          selectedColumn = columnNames.indexOf(task.column);
        }
      }
    }

    function clearSelection() {
      document.querySelectorAll('.task.selected').forEach(task => {
        task.classList.remove('selected');
      });
      selectedTaskId = null;
    }

    function getSelectedTask() {
      return selectedTaskId ? tasks.find(t => t.id === selectedTaskId) : null;
    }

    // Get tasks in visual order for a column
    function getColumnTasksInOrder(columnName) {
      const container = document.getElementById(`${columnName}-tasks`);
      if (!container) return [];

      const taskElements = container.querySelectorAll('.task');
      return Array.from(taskElements).map(element => {
        const taskId = element.dataset.taskId;
        return tasks.find(task => task.id === taskId);
      }).filter(task => task);
    }

    // Navigation functions
    function navigateUp() {
      const columnName = columnNames[selectedColumn];
      const columnTasks = getColumnTasksInOrder(columnName);
      if (columnTasks.length === 0) return;

      if (!selectedTaskId) {
        selectTask(columnTasks[0].id);
        return;
      }

      const currentIndex = columnTasks.findIndex(t => t.id === selectedTaskId);
      if (currentIndex > 0) {
        selectTask(columnTasks[currentIndex - 1].id);
      } else {
        selectTask(columnTasks[columnTasks.length - 1].id);
      }
    }

    function navigateDown() {
      const columnName = columnNames[selectedColumn];
      const columnTasks = getColumnTasksInOrder(columnName);
      if (columnTasks.length === 0) return;

      if (!selectedTaskId) {
        selectTask(columnTasks[0].id);
        return;
      }

      const currentIndex = columnTasks.findIndex(t => t.id === selectedTaskId);
      if (currentIndex < columnTasks.length - 1) {
        selectTask(columnTasks[currentIndex + 1].id);
      } else {
        selectTask(columnTasks[0].id);
      }
    }

    function navigateLeft() {
      selectedColumn = selectedColumn > 0 ? selectedColumn - 1 : columnNames.length - 1;
      const columnTasks = getColumnTasksInOrder(columnNames[selectedColumn]);
      if (columnTasks.length > 0) {
        selectTask(columnTasks[0].id);
      } else {
        clearSelection();
      }
    }

    function navigateRight() {
      selectedColumn = selectedColumn < columnNames.length - 1 ? selectedColumn + 1 : 0;
      const columnTasks = getColumnTasksInOrder(columnNames[selectedColumn]);
      if (columnTasks.length > 0) {
        selectTask(columnTasks[0].id);
      } else {
        clearSelection();
      }
    }

    // Move task functions
    function moveTaskUp() {
      const task = getSelectedTask();
      if (!task || task.column === 'done') return;

      const columnTasks = getColumnTasksInOrder(task.column);
      const currentIndex = columnTasks.findIndex(t => t.id === task.id);

      if (currentIndex > 0) {
        const targetTask = columnTasks[currentIndex - 1];
        const tempOrder = task.order;
        task.order = targetTask.order;
        targetTask.order = tempOrder;

        saveTasks();
        renderTasks();
        selectTask(task.id);
      }
    }

    function moveTaskDown() {
      const task = getSelectedTask();
      if (!task || task.column === 'done') return;

      const columnTasks = getColumnTasksInOrder(task.column);
      const currentIndex = columnTasks.findIndex(t => t.id === task.id);

      if (currentIndex < columnTasks.length - 1) {
        const targetTask = columnTasks[currentIndex + 1];
        const tempOrder = task.order;
        task.order = targetTask.order;
        targetTask.order = tempOrder;

        saveTasks();
        renderTasks();
        selectTask(task.id);
      }
    }

    function moveTaskLeft() {
      const task = getSelectedTask();
      if (!task) return;

      const newColumnIndex = selectedColumn > 0 ? selectedColumn - 1 : columnNames.length - 1;
      const newColumnName = columnNames[newColumnIndex];
      const oldColumn = task.column;

      task.column = newColumnName;

      if (newColumnName === 'done' && oldColumn !== 'done') {
        task.completedAt = new Date().toISOString();
        // Stop focus timer and keep accumulated time for tomatoes
        if (task.focusStartTime) {
          const elapsed = Date.now() - new Date(task.focusStartTime).getTime();
          task.accumulatedFocusTime = (task.accumulatedFocusTime || 0) + elapsed;
        }
        delete task.focusStartTime;
        task.isActive = false;
      } else if (oldColumn === 'done' && newColumnName !== 'done') {
        delete task.completedAt;
        // Reset focus timer but keep tomatoes
        delete task.focusStartTime;
        task.accumulatedFocusTime = 0;
        task.isActive = false;
      }

      const newColumnTasks = tasks.filter(t => t.column === newColumnName && t.id !== task.id);
      task.order = newColumnTasks.length;

      selectedColumn = newColumnIndex;
      saveTasks();
      renderTasks();
      selectTask(task.id);
    }

    function moveTaskRight() {
      const task = getSelectedTask();
      if (!task) return;

      const newColumnIndex = selectedColumn < columnNames.length - 1 ? selectedColumn + 1 : 0;
      const newColumnName = columnNames[newColumnIndex];
      const oldColumn = task.column;

      task.column = newColumnName;

      if (newColumnName === 'done' && oldColumn !== 'done') {
        task.completedAt = new Date().toISOString();
        // Stop focus timer and keep accumulated time for tomatoes
        if (task.focusStartTime) {
          const elapsed = Date.now() - new Date(task.focusStartTime).getTime();
          task.accumulatedFocusTime = (task.accumulatedFocusTime || 0) + elapsed;
        }
        delete task.focusStartTime;
        task.isActive = false;
      } else if (oldColumn === 'done' && newColumnName !== 'done') {
        delete task.completedAt;
        // Reset focus timer but keep tomatoes
        delete task.focusStartTime;
        task.accumulatedFocusTime = 0;
        task.isActive = false;
      }

      const newColumnTasks = tasks.filter(t => t.column === newColumnName && t.id !== task.id);
      task.order = newColumnTasks.length;

      selectedColumn = newColumnIndex;
      saveTasks();
      renderTasks();
      selectTask(task.id);
    }

    // URL detection and title fetching
    function isValidUrl(string) {
      try {
        new URL(string);
        return true;
      } catch (_) {
        return false;
      }
    }

    // Get favicon URL for a given website URL
    function getFaviconUrl(url) {
      try {
        const domain = new URL(url).origin;
        return `${domain}/favicon.ico`;
      } catch (_) {
        return '';
      }
    }

    async function fetchPageTitle(url) {
      try {
        const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(url)}`);
        const data = await response.json();
        const parser = new DOMParser();
        const doc = parser.parseFromString(data.contents, 'text/html');
        const title = doc.querySelector('title');
        return title ? title.textContent.trim() : new URL(url).hostname;
      } catch (error) {
        console.error('Error fetching page title:', error);
        return new URL(url).hostname;
      }
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Prevent shortcuts when modal is open or in input fields
      if (document.getElementById('task-modal').style.display === 'block' ||
        document.getElementById('list-modal').style.display === 'block' ||
        e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }

      // Handle list view keyboard shortcuts
      if (currentView === 'list') {
        switch (e.key) {
          case 'ArrowUp':
            navigateListUp();
            e.preventDefault();
            break;
          case 'ArrowDown':
            navigateListDown();
            e.preventDefault();
            break;
          case 'Enter':
            if (selectedListItemId) {
              openSelectedListItemUrl();
            }
            e.preventDefault();
            break;
          case 'e':
          case 'E':
            if (selectedListItemId) {
              editListItem(selectedListItemId);
            }
            e.preventDefault();
            break;
          case 'Delete':
          case 'Backspace':
            if (selectedListItemId) {
              deleteListItem(selectedListItemId);
            }
            e.preventDefault();
            break;
          case 'n':
          case 'N':
            openListModal();
            e.preventDefault();
            break;
        }
        return;
      }

      // Handle Kanban view keyboard shortcuts
      if (e.shiftKey) {
        // Shift + Arrow = Move task
        switch (e.key) {
          case 'ArrowUp':
            moveTaskUp();
            e.preventDefault();
            break;
          case 'ArrowDown':
            moveTaskDown();
            e.preventDefault();
            break;
          case 'ArrowLeft':
            moveTaskLeft();
            e.preventDefault();
            break;
          case 'ArrowRight':
            moveTaskRight();
            e.preventDefault();
            break;
        }
      } else {
        // Regular navigation and actions
        switch (e.key) {
          case 'ArrowUp':
            navigateUp();
            e.preventDefault();
            break;
          case 'ArrowDown':
            navigateDown();
            e.preventDefault();
            break;
          case 'ArrowLeft':
            navigateLeft();
            e.preventDefault();
            break;
          case 'ArrowRight':
            navigateRight();
            e.preventDefault();
            break;
          case 'Enter':
            if (selectedTaskId) {
              const taskIndex = tasks.findIndex(t => t.id === selectedTaskId);
              if (taskIndex >= 0) {
                editTask(taskIndex);
              }
            }
            e.preventDefault();
            break;
          case 'Delete':
          case 'Backspace':
            if (selectedTaskId) {
              const taskIndex = tasks.findIndex(t => t.id === selectedTaskId);
              if (taskIndex >= 0) {
                deleteTask(taskIndex);
              }
            }
            e.preventDefault();
            break;
          case 'n':
          case 'N':
            // Always add new tasks to the "todo" column when pressing 'n'
            openTaskModal('todo');
            e.preventDefault();
            break;
        }
      }
    });

    // Paste functionality
    document.addEventListener('paste', async (e) => {
      // Only handle paste when not in input fields or modals
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' ||
        document.getElementById('task-modal').style.display === 'block' ||
        document.getElementById('list-modal').style.display === 'block') {
        return;
      }

      const pastedText = e.clipboardData.getData('text').trim();

      if (isValidUrl(pastedText)) {
        e.preventDefault();

        if (currentView === 'list') {
          // Open list modal with URL pre-filled
          currentEditingListItem = null;
          document.getElementById('list-modal-title').textContent = 'Add Task';
          document.getElementById('list-item-title').value = '';
          document.getElementById('list-item-url').value = pastedText;
          document.getElementById('list-modal').style.display = 'block';
          document.getElementById('list-item-title').focus();
        } else {
          // Open kanban modal with URL pre-filled
          currentColumn = 'todo';
          currentEditingTask = null;
          document.getElementById('modal-title').textContent = 'Add Task';
          currentTags = [];
          document.getElementById('task-title').value = '';
          document.getElementById('task-url').value = pastedText;
          document.getElementById('task-notes').value = '';
          renderTagsInput();
          document.getElementById('task-modal').style.display = 'block';
          document.getElementById('task-title').focus();
        }
      }
    });

    // Modal keyboard shortcuts and click outside to close
    document.getElementById('task-modal').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeTaskModal();
      } else if (e.key === 'Enter' && e.target.id !== 'task-notes' && e.target.id !== 'tag-input') {
        saveTask();
      } else if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
        saveTask();
      }
    });

    // Close modal when clicking outside of it
    document.getElementById('task-modal').addEventListener('click', (e) => {
      if (e.target.id === 'task-modal') {
        closeTaskModal();
      }
    });

    // Instructions modal keyboard shortcuts and click outside to close
    document.getElementById('instructions-modal').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeInstructionsModal();
      }
    });

    document.getElementById('instructions-modal').addEventListener('click', (e) => {
      if (e.target.id === 'instructions-modal') {
        closeInstructionsModal();
      }
    });

    // Tags functionality
    function renderTagsInput() {
      const container = document.getElementById('tags-input');
      container.innerHTML = '';

      currentTags.forEach((tag, index) => {
        const tagElement = document.createElement('div');
        tagElement.className = 'tag-item';
        tagElement.innerHTML = `
                    <span>${tag}</span>
                    <button class="tag-remove" onclick="removeTag(${index})" type="button">√ó</button>
                `;
        container.appendChild(tagElement);
      });

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'tag-input';
      input.id = 'tag-input';
      input.placeholder = currentTags.length === 0 ? 'Type and press Enter to add tags' : '';
      input.addEventListener('keydown', handleTagInput);
      input.addEventListener('input', handleTagInputChange);
      input.addEventListener('blur', hideSuggestions);
      container.appendChild(input);

      const suggestionsDiv = document.createElement('div');
      suggestionsDiv.className = 'tag-suggestions';
      suggestionsDiv.id = 'tag-suggestions';
      container.appendChild(suggestionsDiv);
    }

    function handleTagInput(e) {
      const suggestions = document.getElementById('tag-suggestions');
      const selectedSuggestion = suggestions.querySelector('.tag-suggestion.selected');

      if (e.key === 'Enter') {
        e.preventDefault();
        if (selectedSuggestion) {
          addTag(selectedSuggestion.textContent);
          e.target.value = '';
          hideSuggestions();
        } else if (e.target.value.trim()) {
          addTag(e.target.value.trim());
          e.target.value = '';
          hideSuggestions();
        }
      } else if (e.key === 'Backspace' && e.target.value === '' && currentTags.length > 0) {
        removeTag(currentTags.length - 1);
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectNextSuggestion();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectPrevSuggestion();
      } else if (e.key === 'Escape') {
        hideSuggestions();
      }
    }

    function handleTagInputChange(e) {
      const query = e.target.value.trim().toLowerCase();
      if (query.length > 0) {
        showSuggestions(query);
      } else {
        hideSuggestions();
      }
    }

    function showSuggestions(query) {
      const suggestions = document.getElementById('tag-suggestions');
      const filteredTags = Array.from(allTags)
        .filter(tag =>
          tag.toLowerCase().includes(query) &&
          !currentTags.includes(tag)
        )
        .slice(0, 5);

      if (filteredTags.length > 0) {
        suggestions.innerHTML = filteredTags
          .map(tag => `<div class="tag-suggestion" onclick="selectSuggestion('${tag}')">${tag}</div>`)
          .join('');
        suggestions.style.display = 'block';
      } else {
        hideSuggestions();
      }
    }

    function hideSuggestions() {
      setTimeout(() => {
        const suggestions = document.getElementById('tag-suggestions');
        if (suggestions) {
          suggestions.style.display = 'none';
        }
      }, 150);
    }

    function selectSuggestion(tag) {
      addTag(tag);
      document.getElementById('tag-input').value = '';
      hideSuggestions();
      document.getElementById('tag-input').focus();
    }

    function selectNextSuggestion() {
      const suggestions = document.querySelectorAll('.tag-suggestion');
      const current = document.querySelector('.tag-suggestion.selected');

      if (suggestions.length === 0) return;

      if (!current) {
        suggestions[0].classList.add('selected');
      } else {
        current.classList.remove('selected');
        const nextIndex = Array.from(suggestions).indexOf(current) + 1;
        if (nextIndex < suggestions.length) {
          suggestions[nextIndex].classList.add('selected');
        } else {
          suggestions[0].classList.add('selected');
        }
      }
    }

    function selectPrevSuggestion() {
      const suggestions = document.querySelectorAll('.tag-suggestion');
      const current = document.querySelector('.tag-suggestion.selected');

      if (suggestions.length === 0) return;

      if (!current) {
        suggestions[suggestions.length - 1].classList.add('selected');
      } else {
        current.classList.remove('selected');
        const prevIndex = Array.from(suggestions).indexOf(current) - 1;
        if (prevIndex >= 0) {
          suggestions[prevIndex].classList.add('selected');
        } else {
          suggestions[suggestions.length - 1].classList.add('selected');
        }
      }
    }

    function addTag(tagText) {
      if (tagText && !currentTags.includes(tagText)) {
        currentTags.push(tagText);
        renderTagsInput();
        document.getElementById('tag-input').focus();
      }
    }

    function removeTag(index) {
      currentTags.splice(index, 1);
      renderTagsInput();
      document.getElementById('tag-input').focus();
    }

    // Focus timer helper functions
    function getCurrentFocusTime(task) {
      if (!task) return 0;

      let totalTime = task.accumulatedFocusTime || 0;

      // If currently active, add the time since focus started
      if (task.isActive && task.focusStartTime) {
        const elapsed = Date.now() - new Date(task.focusStartTime).getTime();
        totalTime += elapsed;
      }

      return totalTime;
    }

    function formatFocusTime(milliseconds) {
      const totalSeconds = Math.floor(milliseconds / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      if (hours > 0) {
        return `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      } else {
        return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }
    }

    function getTomatoCount(milliseconds) {
      const POMODORO_DURATION = 25 * 60 * 1000; // 25 minutes in milliseconds
      return Math.floor(milliseconds / POMODORO_DURATION);
    }

    function formatTomatoes(count) {
      if (count === 0) return '';
      if (count <= 4) {
        return 'üçÖ'.repeat(count);
      }
      return `üçÖ x${count}`;
    }

    // Toggle on hold status
    function toggleHold(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (task) {
        task.onHold = !task.onHold;
        saveTasks();
        renderTasks();
        // Restore selection after render
        if (selectedTaskId === taskId) {
          selectTask(taskId);
        }
      }
    }

    // Toggle active status (only one task can be active at a time)
    function toggleActive(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;

      // If this task is already active, deactivate it and stop timer
      if (task.isActive) {
        // Stop the timer and accumulate the time
        if (task.focusStartTime) {
          const elapsed = Date.now() - new Date(task.focusStartTime).getTime();
          task.accumulatedFocusTime = (task.accumulatedFocusTime || 0) + elapsed;
          delete task.focusStartTime;
        }
        task.isActive = false;
      } else {
        // Deactivate all other tasks and stop their timers
        tasks.forEach(t => {
          if (t.isActive) {
            if (t.focusStartTime) {
              const elapsed = Date.now() - new Date(t.focusStartTime).getTime();
              t.accumulatedFocusTime = (t.accumulatedFocusTime || 0) + elapsed;
              delete t.focusStartTime;
            }
            t.isActive = false;
          }
        });
        // Activate this task and start timer
        task.isActive = true;
        task.focusStartTime = new Date().toISOString();
        if (!task.accumulatedFocusTime) {
          task.accumulatedFocusTime = 0;
        }
      }

      saveTasks();
      renderTasks();
      // Restore selection after render
      if (selectedTaskId === taskId) {
        selectTask(taskId);
      }
    }

    // Edit start time function
    function editStartTime(event, taskId) {
      event.stopPropagation();

      const task = tasks.find(t => t.id === taskId);
      if (!task) return;

      const currentValue = task.startedAt ? new Date(task.startedAt) : new Date();
      const localDateTime = new Date(currentValue.getTime() - currentValue.getTimezoneOffset() * 60000).toISOString().slice(0, 16);

      const newValue = prompt('Edit start time (leave empty to remove):', localDateTime);

      if (newValue === null) return; // User clicked cancel

      if (newValue.trim() === '') {
        // Remove start time
        delete task.startedAt;
      } else {
        // Update start time
        try {
          task.startedAt = new Date(newValue).toISOString();
        } catch (e) {
          alert('Invalid date format');
          return;
        }
      }

      saveTasks();
      renderTasks();

      // Restore selection after render
      if (selectedTaskId === taskId) {
        selectTask(taskId);
      }
    }

    // Title editing functions
    function toggleTitleEdit() {
      const editBtn = document.getElementById('title-edit-btn');
      const titleElement = document.getElementById('app-title');
      const container = document.querySelector('.title-container');

      if (editBtn.textContent === 'Edit') {
        // Switch to edit mode
        const currentTitle = titleElement ? titleElement.textContent : "Tobi's Task Manager";
        const editInput = document.createElement('input');
        editInput.type = 'text';
        editInput.className = 'title-edit-input';
        editInput.value = currentTitle;
        editInput.id = 'title-edit-input';

        // Replace h1 with input
        if (titleElement) {
          container.replaceChild(editInput, titleElement);
        } else {
          container.insertBefore(editInput, editBtn);
        }
        editBtn.textContent = 'Save';

        // Focus and select the input
        editInput.focus();
        editInput.select();

        // Handle Enter key and Escape key
        editInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            saveTitle();
          } else if (e.key === 'Escape') {
            cancelTitleEdit();
          }
        });
      } else {
        // Save mode
        saveTitle();
      }
    }

    function saveTitle() {
      const input = document.getElementById('title-edit-input');
      const editBtn = document.getElementById('title-edit-btn');
      const container = document.querySelector('.title-container');

      if (!input) return;

      const newTitle = input.value.trim();
      if (newTitle === '') {
        alert('Title cannot be empty');
        return;
      }

      // Create new h1 element
      const titleElement = document.createElement('h1');
      titleElement.id = 'app-title';
      titleElement.textContent = newTitle;

      // Replace input with h1
      container.replaceChild(titleElement, input);
      editBtn.textContent = 'Edit';

      // Save to localStorage
      localStorage.setItem('taskManager_appName', newTitle);

      // Update document title
      document.title = newTitle;
    }

    function cancelTitleEdit() {
      const input = document.getElementById('title-edit-input');
      const editBtn = document.getElementById('title-edit-btn');
      const container = document.querySelector('.title-container');

      if (!input) return;

      // Restore the original title
      const savedTitle = localStorage.getItem('taskManager_appName') || "Tobi's Task Manager";
      const titleElement = document.createElement('h1');
      titleElement.id = 'app-title';
      titleElement.textContent = savedTitle;

      // Replace input with h1
      container.replaceChild(titleElement, input);
      editBtn.textContent = 'Edit';
    }

    function loadAppName() {
      const savedName = localStorage.getItem('taskManager_appName');
      if (savedName) {
        const titleElement = document.getElementById('app-title');
        if (titleElement) {
          titleElement.textContent = savedName;
        }
        document.title = savedName;
      }
    }

    // ==========================================
    // SIMPLE LIST FUNCTIONS
    // ==========================================

    // Load list items from localStorage
    function loadListItems() {
      const saved = localStorage.getItem('taskManager_listItems');
      if (saved) {
        listItems = JSON.parse(saved);
        // Populate allListTags from existing items
        listItems.forEach(item => {
          if (item.tags) {
            item.tags.forEach(tag => allListTags.add(tag));
          }
        });
      }
    }

    // Save list items to localStorage
    function saveListItems() {
      localStorage.setItem('taskManager_listItems', JSON.stringify(listItems));
    }

    // Generate unique ID for list items
    function generateListItemId() {
      return 'li_' + Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    // Switch between Kanban and List views
    function switchView(view) {
      currentView = view;
      localStorage.setItem('taskManager_currentView', view);

      // Toggle visibility
      const board = document.getElementById('board');
      const listView = document.getElementById('list-view');

      if (view === 'kanban') {
        board.style.display = 'grid';
        listView.style.display = 'none';
      } else {
        board.style.display = 'none';
        listView.style.display = 'block';
        renderListItems();
      }

      // Update nav buttons
      document.querySelectorAll('.view-nav-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === view);
      });

      // Clear selections when switching views
      clearSelection();
      selectedListItemId = null;
    }

    // Initialize view on page load
    function initializeView() {
      if (currentView === 'list') {
        switchView('list');
      }
    }

    // State for collapsed completed section
    let listCompletedCollapsed = localStorage.getItem('taskManager_listCompletedCollapsed') === 'true';

    // Render all list items
    function renderListItems() {
      const container = document.getElementById('list-items');
      const emptyState = document.getElementById('list-empty');
      const countBadge = document.getElementById('list-count');

      container.innerHTML = '';

      // Render tag filter bar
      renderTagFilterBar();

      // Separate active and completed items
      let activeItems = listItems.filter(i => !i.completed).sort((a, b) => (a.order || 0) - (b.order || 0));
      let completedItems = listItems.filter(i => i.completed).sort((a, b) => {
        // Sort by completedAt descending (most recent first)
        return new Date(b.completedAt || 0) - new Date(a.completedAt || 0);
      });

      // Apply tag filter
      activeItems = filterByTags(activeItems);
      completedItems = filterByTags(completedItems);

      const totalFiltered = activeItems.length + completedItems.length;

      // Update count badge
      if (listItems.length > 0) {
        if (activeTagFilters.size > 0) {
          countBadge.textContent = `${totalFiltered} of ${listItems.length} shown`;
        } else if (completedItems.length > 0) {
          countBadge.textContent = `${completedItems.length}/${listItems.length} done`;
        } else {
          countBadge.textContent = `${listItems.length} task${listItems.length !== 1 ? 's' : ''}`;
        }
      } else {
        countBadge.textContent = '';
      }

      if (listItems.length === 0) {
        emptyState.style.display = 'block';
        container.style.display = 'none';
        return;
      }

      emptyState.style.display = 'none';
      container.style.display = 'block';

      // Show message if filter has no results
      if (totalFiltered === 0 && activeTagFilters.size > 0) {
        const noResults = document.createElement('div');
        noResults.className = 'list-no-results';
        noResults.innerHTML = `
          <div class="list-no-results-text">No tasks match the selected tags</div>
          <button class="list-no-results-clear" onclick="clearTagFilters()">Clear filters</button>
        `;
        container.appendChild(noResults);
        return;
      }

      // Render active items
      activeItems.forEach(item => {
        const element = createListItemElement(item);
        container.appendChild(element);
      });

      // Render completed section if there are completed items
      if (completedItems.length > 0) {
        const completedSection = document.createElement('div');
        completedSection.className = 'list-completed-section';

        const completedHeader = document.createElement('div');
        completedHeader.className = `list-completed-header ${listCompletedCollapsed ? 'collapsed' : ''}`;
        completedHeader.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="6 9 12 15 18 9"/>
          </svg>
          Completed
          <span class="list-completed-count">(${completedItems.length})</span>
        `;
        completedHeader.onclick = toggleListCompletedSection;

        const completedContainer = document.createElement('div');
        completedContainer.className = `list-completed-items ${listCompletedCollapsed ? 'collapsed' : ''}`;
        completedContainer.id = 'list-completed-items';

        // Group completed items by date
        const groupOrder = ['today', 'yesterday', 'last7days', 'last30days', 'older'];
        const groupedItems = {};

        completedItems.forEach(item => {
          const group = getDateGroup(item.completedAt);
          if (!groupedItems[group]) groupedItems[group] = [];
          groupedItems[group].push(item);
        });

        // Render grouped items
        groupOrder.forEach(group => {
          if (groupedItems[group] && groupedItems[group].length > 0) {
            const groupHeader = document.createElement('div');
            groupHeader.className = 'list-date-group-header';
            groupHeader.textContent = getDateGroupLabel(group);
            completedContainer.appendChild(groupHeader);

            groupedItems[group].forEach(item => {
              const element = createListItemElement(item);
              completedContainer.appendChild(element);
            });
          }
        });

        // Set max-height for animation
        if (!listCompletedCollapsed) {
          setTimeout(() => {
            completedContainer.style.maxHeight = completedContainer.scrollHeight + 'px';
          }, 0);
        }

        completedSection.appendChild(completedHeader);
        completedSection.appendChild(completedContainer);
        container.appendChild(completedSection);
      }

      // Set up drag and drop for list
      setupListDragAndDrop();
    }

    // Toggle completed section collapse
    function toggleListCompletedSection() {
      listCompletedCollapsed = !listCompletedCollapsed;
      localStorage.setItem('taskManager_listCompletedCollapsed', listCompletedCollapsed);

      const header = document.querySelector('.list-completed-header');
      const items = document.getElementById('list-completed-items');

      if (header) header.classList.toggle('collapsed', listCompletedCollapsed);
      if (items) {
        if (listCompletedCollapsed) {
          items.classList.add('collapsed');
        } else {
          items.classList.remove('collapsed');
          items.style.maxHeight = items.scrollHeight + 'px';
        }
      }
    }

    // Get date group for completed task
    function getDateGroup(dateString) {
      if (!dateString) return 'older';

      const date = new Date(dateString);
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      const lastWeekStart = new Date(today);
      lastWeekStart.setDate(lastWeekStart.getDate() - 7);
      const lastMonthStart = new Date(today);
      lastMonthStart.setDate(lastMonthStart.getDate() - 30);

      const taskDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

      if (taskDate >= today) {
        return 'today';
      } else if (taskDate >= yesterday) {
        return 'yesterday';
      } else if (taskDate >= lastWeekStart) {
        return 'last7days';
      } else if (taskDate >= lastMonthStart) {
        return 'last30days';
      } else {
        return 'older';
      }
    }

    function getDateGroupLabel(group) {
      const labels = {
        'today': 'Today',
        'yesterday': 'Yesterday',
        'last7days': 'Last 7 days',
        'last30days': 'Last 30 days',
        'older': 'Older'
      };
      return labels[group] || group;
    }

    // Render tag filter bar
    function renderTagFilterBar() {
      const filterBar = document.getElementById('list-filter-bar');
      const selectedContainer = document.getElementById('list-filter-selected');
      const optionsContainer = document.getElementById('list-filter-options');
      const placeholder = document.getElementById('list-filter-placeholder');

      // Only show if there are tags
      if (allListTags.size === 0) {
        filterBar.style.display = 'none';
        return;
      }

      filterBar.style.display = 'flex';

      // Render selected tags in trigger
      selectedContainer.innerHTML = '';
      activeTagFilters.forEach(tag => {
        const tagEl = document.createElement('span');
        tagEl.className = 'list-filter-tag';
        tagEl.style.background = getTagColor(tag);
        tagEl.innerHTML = `${escapeHtml(tag)}<button onclick="event.stopPropagation(); toggleTagFilter('${escapeHtml(tag)}')">&times;</button>`;
        selectedContainer.appendChild(tagEl);
      });

      // Show/hide placeholder
      placeholder.style.display = activeTagFilters.size > 0 ? 'none' : 'block';

      // Render all tags in dropdown
      const sortedTags = [...allListTags].sort();
      optionsContainer.innerHTML = '';
      sortedTags.forEach(tag => {
        const isSelected = activeTagFilters.has(tag);
        const optionEl = document.createElement('div');
        optionEl.className = `list-filter-option ${isSelected ? 'selected' : ''}`;
        optionEl.onclick = (e) => {
          e.stopPropagation();
          toggleTagFilter(tag);
        };
        optionEl.innerHTML = `
          <span class="list-filter-option-color" style="background: ${getTagColor(tag)}"></span>
          <span>${escapeHtml(tag)}</span>
          <svg class="list-filter-option-check" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <polyline points="20 6 9 17 4 12"/>
          </svg>
        `;
        optionsContainer.appendChild(optionEl);
      });
    }

    // Toggle filter dropdown open/close
    function toggleFilterDropdown() {
      const multiselect = document.getElementById('list-filter-multiselect');
      multiselect.classList.toggle('open');
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      const multiselect = document.getElementById('list-filter-multiselect');
      if (multiselect && !multiselect.contains(e.target)) {
        multiselect.classList.remove('open');
      }
    });

    // Toggle a tag filter
    function toggleTagFilter(tag) {
      if (activeTagFilters.has(tag)) {
        activeTagFilters.delete(tag);
      } else {
        activeTagFilters.add(tag);
      }
      renderTagFilterBar();
      renderListItems();
    }

    // Clear all tag filters
    function clearTagFilters() {
      activeTagFilters.clear();
      renderTagFilterBar();
      renderListItems();
    }

    // Filter items by active tags (OR logic)
    function filterByTags(items) {
      if (activeTagFilters.size === 0) return items;

      return items.filter(item => {
        if (!item.tags || item.tags.length === 0) return false;
        return item.tags.some(tag => activeTagFilters.has(tag));
      });
    }

    // Create a list item element
    function createListItemElement(item) {
      const div = document.createElement('div');
      div.className = 'list-item';
      if (item.completed) div.classList.add('completed');
      div.draggable = true;
      div.dataset.itemId = item.id;

      if (selectedListItemId === item.id) {
        div.classList.add('selected');
      }

      const hasUrl = item.url && item.url.trim();
      const faviconUrl = hasUrl ? getFaviconUrl(item.url) : '';

      // Build title content
      let titleContent;
      const completedTimeHtml = item.completed && item.completedAt
        ? `<div class="completed-time">Completed ${formatCompletedTime(item.completedAt)}</div>`
        : '';

      // Build tags HTML
      const tagsHtml = item.tags && item.tags.length > 0
        ? `<div class="list-item-tags">${item.tags.map(tag => `<span class="list-item-tag" style="background: ${getTagColor(tag)}">${escapeHtml(tag)}</span>`).join('')}</div>`
        : '';

      // Build notes HTML (inline)
      const notesHtml = item.notes && item.notes.trim()
        ? `<span class="list-item-notes">${escapeHtml(item.notes)}</span>`
        : '';

      if (hasUrl) {
        titleContent = `
          <div class="title-text">
            <a href="${escapeHtml(item.url)}" target="_blank" draggable="false">${escapeHtml(item.title)}</a>${tagsHtml}${notesHtml}
          </div>
          ${completedTimeHtml}
        `;
      } else {
        titleContent = `
          <div class="title-text">
            ${escapeHtml(item.title)}${tagsHtml}${notesHtml}
          </div>
          ${completedTimeHtml}
        `;
      }

      // Build favicon/placeholder
      let faviconContent;
      if (hasUrl) {
        faviconContent = `
          <div class="list-favicon-wrapper" draggable="false">
            <img src="${faviconUrl}" class="list-favicon" draggable="false" onerror="this.parentElement.innerHTML='<svg class=\\'list-favicon-placeholder\\' viewBox=\\'0 0 24 24\\' fill=\\'none\\' stroke=\\'currentColor\\' stroke-width=\\'1.5\\'><path d=\\'M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71\\'/><path d=\\'M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71\\'/></svg>'" alt="">
          </div>
        `;
      } else {
        faviconContent = `
          <div class="list-favicon-wrapper">
            <svg class="list-favicon-placeholder" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
              <rect x="9" y="3" width="6" height="4" rx="1"/>
            </svg>
          </div>
        `;
      }

      div.innerHTML = `
        <div class="drag-handle">
          <span class="drag-handle-dot"></span>
          <span class="drag-handle-dot"></span>
          <span class="drag-handle-dot"></span>
          <span class="drag-handle-dot"></span>
          <span class="drag-handle-dot"></span>
          <span class="drag-handle-dot"></span>
        </div>
        <div class="list-checkbox ${item.completed ? 'checked' : ''}" onclick="toggleListItemComplete('${item.id}')">
          <svg viewBox="0 0 12 12">
            <polyline points="2,6 5,9 10,3"/>
          </svg>
        </div>
        ${faviconContent}
        <div class="list-item-title">
          ${titleContent}
        </div>
        <div class="list-item-actions">
          <button class="list-item-btn edit" onclick="editListItem('${item.id}')" title="Edit">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
              <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
          </button>
          <button class="list-item-btn delete" onclick="deleteListItem('${item.id}')" title="Delete">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="3 6 5 6 21 6"/>
              <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
            </svg>
          </button>
        </div>
      `;

      // Click to select
      div.addEventListener('click', (e) => {
        if (!e.target.closest('a') && !e.target.closest('button') && !e.target.closest('.list-checkbox')) {
          selectListItem(item.id);
        }
      });

      // Double-click to edit
      div.addEventListener('dblclick', (e) => {
        if (!e.target.closest('a') && !e.target.closest('.list-checkbox')) {
          editListItem(item.id);
        }
      });

      return div;
    }

    // Toggle list item completion
    function toggleListItemComplete(itemId) {
      const item = listItems.find(i => i.id === itemId);
      if (item) {
        item.completed = !item.completed;
        if (item.completed) {
          item.completedAt = new Date().toISOString();
        } else {
          delete item.completedAt;
        }
        saveListItems();
        renderListItems();
      }
    }

    // Format completion time for display
    function formatCompletedTime(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays === 1) return 'Yesterday';
      if (diffDays < 7) return `${diffDays}d ago`;

      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }

    // Extract domain from URL for display
    function extractDomain(url) {
      try {
        const urlObj = new URL(url);
        return urlObj.hostname.replace('www.', '');
      } catch (_) {
        return url;
      }
    }

    // Select a list item
    function selectListItem(itemId) {
      document.querySelectorAll('.list-item.selected').forEach(el => {
        el.classList.remove('selected');
      });

      selectedListItemId = itemId;
      const element = document.querySelector(`[data-item-id="${itemId}"]`);
      if (element) {
        element.classList.add('selected');
        element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    // Custom tag colors storage
    let customTagColors = JSON.parse(localStorage.getItem('taskManager_tagColors') || '{}');

    function saveTagColors() {
      localStorage.setItem('taskManager_tagColors', JSON.stringify(customTagColors));
    }

    // Get consistent color for a tag based on its name
    function getTagColor(tagName) {
      // Check for custom color first
      if (customTagColors[tagName] !== undefined) {
        return `var(--tag-color-${customTagColors[tagName]})`;
      }
      // Fall back to hash-based color
      let hash = 5381;
      for (let i = 0; i < tagName.length; i++) {
        hash = ((hash << 5) + hash) ^ tagName.charCodeAt(i);
      }
      const colorIndex = Math.abs(hash) % 16;
      return `var(--tag-color-${colorIndex})`;
    }

    // Get current color index for a tag
    function getTagColorIndex(tagName) {
      if (customTagColors[tagName] !== undefined) {
        return customTagColors[tagName];
      }
      let hash = 5381;
      for (let i = 0; i < tagName.length; i++) {
        hash = ((hash << 5) + hash) ^ tagName.charCodeAt(i);
      }
      return Math.abs(hash) % 16;
    }

    // Cycle tag color to next color
    function cycleTagColor(tagName) {
      const currentIndex = getTagColorIndex(tagName);
      const nextIndex = (currentIndex + 1) % 16;
      customTagColors[tagName] = nextIndex;
      saveTagColors();
      renderListTagsInput();
      renderListItems();
    }

    // Render list tags input
    function renderListTagsInput() {
      const container = document.getElementById('list-tags-input');
      const input = document.getElementById('list-tag-input');

      // Remove existing tags (keep input)
      const existingTags = container.querySelectorAll('.tag');
      existingTags.forEach(tag => tag.remove());

      // Add current tags before input
      currentListTags.forEach(tag => {
        const tagElement = document.createElement('span');
        tagElement.className = 'tag';
        tagElement.style.background = getTagColor(tag);
        tagElement.innerHTML = `
          <button type="button" class="tag-color-btn" onclick="cycleTagColor('${escapeHtml(tag)}')" title="Change color">‚óè</button>
          ${escapeHtml(tag)}
          <button type="button" onclick="removeListTag('${escapeHtml(tag)}')">&times;</button>
        `;
        container.insertBefore(tagElement, input);
      });
    }

    // Add a tag to list item
    function addListTag(tag) {
      const trimmedTag = tag.trim().toLowerCase();
      if (trimmedTag && !currentListTags.includes(trimmedTag)) {
        currentListTags.push(trimmedTag);
        allListTags.add(trimmedTag);
        renderListTagsInput();
      }
      document.getElementById('list-tag-input').value = '';
      hideListTagSuggestions();
    }

    // Remove a tag from list item
    function removeListTag(tag) {
      currentListTags = currentListTags.filter(t => t !== tag);
      renderListTagsInput();
    }

    // Show list tag suggestions
    function showListTagSuggestions(filter) {
      const suggestionsContainer = document.getElementById('list-tag-suggestions');
      const matchingTags = [...allListTags].filter(tag =>
        tag.includes(filter.toLowerCase()) && !currentListTags.includes(tag)
      );

      if (matchingTags.length === 0 || !filter) {
        suggestionsContainer.style.display = 'none';
        return;
      }

      suggestionsContainer.innerHTML = matchingTags.map(tag =>
        `<div class="tag-suggestion" onclick="addListTag('${escapeHtml(tag)}')">${escapeHtml(tag)}</div>`
      ).join('');
      suggestionsContainer.style.display = 'block';
    }

    // Hide list tag suggestions
    function hideListTagSuggestions() {
      document.getElementById('list-tag-suggestions').style.display = 'none';
    }

    // Open list modal for adding
    function openListModal() {
      currentEditingListItem = null;
      currentListTags = [];
      document.getElementById('list-modal-title').textContent = 'Add Task';
      document.getElementById('list-item-title').value = '';
      document.getElementById('list-item-url').value = '';
      document.getElementById('list-item-notes').value = '';
      document.getElementById('list-tag-input').value = '';
      renderListTagsInput();
      document.getElementById('list-modal').style.display = 'block';
      document.getElementById('list-item-title').focus();
    }

    // Close list modal
    function closeListModal() {
      document.getElementById('list-modal').style.display = 'none';
      currentEditingListItem = null;
      currentListTags = [];
      hideListTagSuggestions();
    }

    // Edit a list item
    function editListItem(itemId) {
      const item = listItems.find(i => i.id === itemId);
      if (!item) return;

      currentEditingListItem = itemId;
      currentListTags = item.tags ? [...item.tags] : [];
      document.getElementById('list-modal-title').textContent = 'Edit Task';
      document.getElementById('list-item-title').value = item.title || '';
      document.getElementById('list-item-url').value = item.url || '';
      document.getElementById('list-item-notes').value = item.notes || '';
      document.getElementById('list-tag-input').value = '';
      renderListTagsInput();
      document.getElementById('list-modal').style.display = 'block';
      document.getElementById('list-item-title').focus();
    }

    // Delete a list item
    function deleteListItem(itemId) {
      if (confirm('Are you sure you want to delete this task?')) {
        listItems = listItems.filter(i => i.id !== itemId);
        if (selectedListItemId === itemId) {
          selectedListItemId = null;
        }
        saveListItems();
        renderListItems();
      }
    }

    // Save list item (add or edit)
    function saveListItem() {
      const title = document.getElementById('list-item-title').value.trim();
      const url = document.getElementById('list-item-url').value.trim();
      const notes = document.getElementById('list-item-notes').value.trim();

      if (!title) {
        alert('Please enter a title');
        return;
      }

      if (url && !isValidUrl(url)) {
        alert('Please enter a valid URL');
        return;
      }

      if (currentEditingListItem) {
        // Edit existing item
        const item = listItems.find(i => i.id === currentEditingListItem);
        if (item) {
          item.title = title;
          item.url = url;
          item.notes = notes;
          item.tags = [...currentListTags];
        }
      } else {
        // Add new item at the top
        listItems.forEach(item => {
          item.order = (item.order || 0) + 1;
        });

        const newItem = {
          id: generateListItemId(),
          title: title,
          url: url,
          notes: notes,
          tags: [...currentListTags],
          order: 0,
          createdAt: new Date().toISOString()
        };
        listItems.push(newItem);
      }

      saveListItems();
      renderListItems();
      closeListModal();
    }

    // Set up drag and drop for list items
    function setupListDragAndDrop() {
      const container = document.getElementById('list-items');
      const items = container.querySelectorAll('.list-item');

      items.forEach(item => {
        item.addEventListener('dragstart', handleListDragStart);
        item.addEventListener('dragend', handleListDragEnd);
      });

      container.addEventListener('dragover', handleListDragOver);
      container.addEventListener('drop', handleListDrop);
    }

    function handleListDragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.itemId);
      e.target.classList.add('dragging');
    }

    function handleListDragEnd(e) {
      e.target.classList.remove('dragging');
    }

    function handleListDragOver(e) {
      e.preventDefault();
      const dragging = document.querySelector('.list-item.dragging');
      if (!dragging) return;

      const container = document.getElementById('list-items');
      const afterElement = getListDragAfterElement(container, e.clientY);

      if (afterElement == null) {
        container.appendChild(dragging);
      } else {
        container.insertBefore(dragging, afterElement);
      }
    }

    function getListDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.list-item:not(.dragging)')];

      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;

        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function handleListDrop(e) {
      e.preventDefault();

      // Update order based on DOM order
      const container = document.getElementById('list-items');
      const items = container.querySelectorAll('.list-item');

      items.forEach((element, index) => {
        const itemId = element.dataset.itemId;
        const item = listItems.find(i => i.id === itemId);
        if (item) {
          item.order = index;
        }
      });

      saveListItems();
    }

    // Navigate list items with keyboard
    function navigateListUp() {
      const sortedItems = [...listItems].sort((a, b) => (a.order || 0) - (b.order || 0));
      if (sortedItems.length === 0) return;

      if (!selectedListItemId) {
        selectListItem(sortedItems[0].id);
        return;
      }

      const currentIndex = sortedItems.findIndex(i => i.id === selectedListItemId);
      if (currentIndex > 0) {
        selectListItem(sortedItems[currentIndex - 1].id);
      } else {
        selectListItem(sortedItems[sortedItems.length - 1].id);
      }
    }

    function navigateListDown() {
      const sortedItems = [...listItems].sort((a, b) => (a.order || 0) - (b.order || 0));
      if (sortedItems.length === 0) return;

      if (!selectedListItemId) {
        selectListItem(sortedItems[0].id);
        return;
      }

      const currentIndex = sortedItems.findIndex(i => i.id === selectedListItemId);
      if (currentIndex < sortedItems.length - 1) {
        selectListItem(sortedItems[currentIndex + 1].id);
      } else {
        selectListItem(sortedItems[0].id);
      }
    }

    // Open selected list item's URL
    function openSelectedListItemUrl() {
      if (!selectedListItemId) return;
      const item = listItems.find(i => i.id === selectedListItemId);
      if (item && item.url && item.url.trim()) {
        window.open(item.url, '_blank');
      }
    }

    // List modal event handlers
    document.getElementById('list-modal').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeListModal();
      } else if (e.key === 'Enter' && !e.shiftKey && e.target.id !== 'list-tag-input') {
        e.preventDefault();
        saveListItem();
      }
    });

    document.getElementById('list-modal').addEventListener('click', (e) => {
      if (e.target.id === 'list-modal') {
        closeListModal();
      }
    });

    // List tag input event handlers
    document.getElementById('list-tag-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const value = e.target.value.trim();
        if (value) {
          addListTag(value);
        }
      } else if (e.key === 'Backspace' && e.target.value === '' && currentListTags.length > 0) {
        removeListTag(currentListTags[currentListTags.length - 1]);
      }
    });

    document.getElementById('list-tag-input').addEventListener('input', (e) => {
      showListTagSuggestions(e.target.value);
    });

    document.getElementById('list-tag-input').addEventListener('blur', () => {
      setTimeout(hideListTagSuggestions, 200);
    });

    // Initialize the app
    loadAppName();
    loadTasks();
    loadListItems();
    loadCollapsedState();
    setupDropZones();
    initializeView();

    // Load last saved time from localStorage
    const savedTime = localStorage.getItem('taskManager_lastSaved');
    if (savedTime) {
      lastSavedTime = new Date(savedTime);
      updateSyncStatus('synced');
    } else {
      // Show initial state if no saved time exists
      const indicator = document.getElementById('sync-indicator');
      if (indicator) {
        indicator.textContent = 'Not yet saved';
        indicator.className = 'sync-indicator';
      }
    }

    // Update timestamp display every minute
    setInterval(refreshSyncTimestamp, 60000);

    // Update focus timer display every second
    function updateFocusTimers() {
      const activeTask = tasks.find(t => t.isActive);
      if (activeTask) {
        const timerElements = document.querySelectorAll('.task-focus-timer');
        timerElements.forEach(element => {
          const taskId = element.dataset.taskId;
          const task = tasks.find(t => t.id === taskId);
          if (task && task.isActive) {
            const focusTime = getCurrentFocusTime(task);
            const tomatoCount = getTomatoCount(focusTime);
            const tomatoes = formatTomatoes(tomatoCount);

            const timerDisplay = element.querySelector('.focus-timer-display');
            if (timerDisplay) {
              timerDisplay.textContent = `‚è± ${formatFocusTime(focusTime)}`;
            }

            // Update tomatoes if count changed
            const tomatoDisplay = element.querySelector('.task-tomatoes');
            if (tomatoes && !tomatoDisplay) {
              // Add tomato display if it doesn't exist
              element.innerHTML += `<div class="task-tomatoes">${tomatoes}</div>`;
            } else if (tomatoes && tomatoDisplay) {
              // Update existing tomato display
              tomatoDisplay.textContent = tomatoes;
            }
          }
        });
      }
    }
    setInterval(updateFocusTimers, 1000);

    // Set initial column focus
    setTimeout(() => {
      if (!selectedTaskId && tasks.length > 0) {
        // Find first column with tasks
        for (let i = 0; i < columnNames.length; i++) {
          const columnTasks = getColumnTasksInOrder(columnNames[i]);
          if (columnTasks.length > 0) {
            selectedColumn = i;
            break;
          }
        }
      }
    }, 100);

    // Register service worker for PWA support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered successfully:', registration.scope);
          })
          .catch((error) => {
            console.log('Service Worker registration failed:', error);
          });
      });
    }
  </script>
</body>

</html>
