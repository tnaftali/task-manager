<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#8b7355">
  <meta name="description" content="A personal task management application with drag-and-drop functionality">
  <title>Tobi's Task Manager</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Crect width='24' height='24' rx='6' fill='%23ffffff'/%3E%3Cpath d='M9 11l3 3l8-8' fill='none' stroke='%238b7355' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11' fill='none' stroke='%238b7355' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Fraunces:ital,opsz,wght@0,9..144,400;0,9..144,500;1,9..144,400&display=swap');

    :root {
      /* Modern Beige/Cream Color Scheme */
      --background: #f0ebe3;
      --surface: #f2efea;
      --surface-elevated: #ffffff;
      --border: #e5e0d7;
      --border-hover: #d1ccc1;

      /* Text Colors */
      --text-primary: #2d2a26;
      --text-secondary: #6b6560;
      --text-muted: #9a9389;

      /* Column Colors - Subtle differentiation */
      --todo-accent: #8b7355;
      --todo-bg: #f9f7f4;
      --progress-accent: #6b8394;
      --progress-bg: #f4f7f9;
      --done-accent: #7a9471;
      --done-bg: #f6f9f6;

      /* Interactive Elements */
      --accent: #8b7355;
      --accent-hover: #6d5a44;
      --danger: #c85a5a;
      --danger-hover: #b04545;
      --success: #7a9471;
      --warning: #d4a574;

      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(45, 42, 38, 0.04);
      --shadow-md: 0 4px 8px rgba(45, 42, 38, 0.08);
      --shadow-lg: 0 8px 16px rgba(45, 42, 38, 0.12);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background-color: var(--background);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 32px;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .title-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-bottom: 48px;
      position: relative;
    }

    h1 {
      text-align: center;
      margin: 0;
      color: var(--accent-hover);
      font-size: 2.25rem;
      font-weight: 400;
      font-family: 'Fraunces', Georgia, serif;
      letter-spacing: -0.02em;
    }

    .title-edit-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.875rem;
      transition: all 0.2s ease;
      opacity: 0.6;
      font-family: 'Inter', sans-serif;
    }

    .title-edit-btn:hover {
      opacity: 1;
      background-color: var(--surface-elevated);
      color: var(--text-primary);
      border-color: var(--border-hover);
    }

    .title-edit-input {
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 2.25rem;
      font-weight: 400;
      font-family: 'Fraunces', Georgia, serif;
      letter-spacing: -0.02em;
      color: var(--accent-hover);
      min-width: 300px;
      max-width: 600px;
      text-align: center;
      outline: none;
    }

    .title-edit-input:focus {
      border-color: var(--accent);
    }

    .board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
      max-width: 1400px;
      margin: 0 auto;
    }

    .column {
      background-color: var(--surface);
      border-radius: 16px;
      padding: 24px;
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 200px);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
      transition: all 0.2s ease;
    }

    .column[data-column="todo"] {
      background-color: var(--todo-bg);
      border-color: rgba(139, 115, 85, 0.2);
    }

    .column[data-column="in-progress"] {
      background-color: var(--progress-bg);
      border-color: rgba(107, 131, 148, 0.2);
    }

    .column[data-column="done"] {
      background-color: var(--done-bg);
      border-color: rgba(122, 148, 113, 0.2);
    }

    .column-header {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 24px;
      text-align: center;
      padding: 12px 16px;
      border-radius: 12px;
      background-color: var(--surface-elevated);
      cursor: pointer;
      user-select: none;
      transition: all 0.2s ease;
      position: relative;
      border: 1px solid var(--border);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.875rem;
    }

    .column-header:hover {
      background-color: var(--surface-elevated);
      border-color: var(--border-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .column-header::after {
      content: '‚ñº';
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.75rem;
      opacity: 0.5;
      transition: transform 0.2s ease;
    }

    .column.collapsed .column-header::after {
      transform: translateY(-50%) rotate(-90deg);
    }

    .column.collapsed .tasks-container,
    .column.collapsed .add-task-btn {
      display: none;
    }

    .column-header.todo {
      color: var(--todo-accent);
      border-color: rgba(139, 115, 85, 0.3);
    }

    .column-header.in-progress {
      color: var(--progress-accent);
      border-color: rgba(107, 131, 148, 0.3);
    }

    .column-header.done {
      color: var(--done-accent);
      border-color: rgba(122, 148, 113, 0.3);
    }

    .tasks-container {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 20px;
      padding: 4px;
    }

    .task {
      background-color: var(--surface-elevated);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      cursor: move;
      transition: all 0.2s ease;
      border: 1px solid var(--border);
      position: relative;
      box-shadow: var(--shadow-sm);
    }

    .task:hover {
      border-color: var(--border-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .task.selected {
      border-color: var(--accent);
      box-shadow: var(--shadow-md);
    }

    .task.dragging {
      opacity: 0.6;
      transform: rotate(2deg);
      box-shadow: var(--shadow-lg);
    }

    .task-title {
      font-weight: 500;
      margin-bottom: 8px;
      color: var(--text-primary);
      word-wrap: break-word;
      line-height: 1.4;
      font-size: 0.95rem;
    }

    .task-url-container {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }

    .task-favicon {
      width: 24px;
      height: 24px;
      flex-shrink: 0;
      border-radius: 8px;
      border: 1px solid var(--border);
      background-color: var(--surface);
      padding: 2px;
    }

    .task-url {
      color: var(--accent);
      text-decoration: none;
      font-size: 0.85rem;
      word-break: break-all;
      transition: color 0.2s ease;
    }

    .task-url:hover {
      color: var(--accent-hover);
      text-decoration: underline;
    }

    .task-actions {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .task:hover .task-actions {
      opacity: 1;
    }

    .action-btn {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      padding: 6px;
      border-radius: 6px;
      font-size: 12px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
    }

    .action-btn:hover {
      background-color: var(--surface-elevated);
      color: var(--text-primary);
      border-color: var(--border-hover);
      transform: translateY(-1px);
    }

    .action-btn.delete:hover {
      color: var(--danger);
      border-color: var(--danger);
      background-color: rgba(200, 90, 90, 0.1);
    }

    .action-btn.edit:hover {
      color: var(--accent);
      border-color: var(--accent);
      background-color: rgba(139, 115, 85, 0.1);
    }

    .action-btn.duplicate:hover {
      color: var(--accent);
      border-color: var(--accent);
      background-color: rgba(139, 115, 85, 0.1);
    }

    .add-task-btn {
      background-color: var(--surface-elevated);
      color: var(--text-muted);
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 16px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s ease;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .add-task-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background-color: rgba(139, 115, 85, 0.05);
      transform: translateY(-1px);
    }

    .drag-over {
      border: 2px dashed var(--accent);
      background-color: rgba(139, 115, 85, 0.1);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(45, 42, 38, 0.6);
      backdrop-filter: blur(4px);
      z-index: 1000;
    }

    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--surface-elevated);
      padding: 32px;
      border-radius: 16px;
      width: 90%;
      max-width: 500px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-lg);
    }

    .modal h3 {
      margin-bottom: 24px;
      color: var(--text-primary);
      font-weight: 600;
      font-size: 1.25rem;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-secondary);
      font-weight: 500;
      font-size: 0.9rem;
    }

    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background-color: var(--surface);
      color: var(--text-primary);
      font-size: 16px;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .form-group textarea {
      resize: vertical;
      min-height: 80px;
    }

    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .btn {
      padding: 12px 24px;
      border: 1px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      font-family: inherit;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }

    .btn-primary {
      background-color: var(--accent);
      color: var(--surface-elevated);
      border-color: var(--accent);
    }

    .btn-primary:hover {
      background-color: var(--accent-hover);
      border-color: var(--accent-hover);
      transform: translateY(-1px);
    }

    .btn-secondary {
      background-color: var(--surface);
      color: var(--text-secondary);
      border-color: var(--border);
    }

    .btn-secondary:hover {
      background-color: var(--surface-elevated);
      color: var(--text-primary);
      border-color: var(--border-hover);
    }

    .loading {
      color: var(--warning);
    }

    .tasks-container::-webkit-scrollbar {
      width: 6px;
    }

    .tasks-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .tasks-container::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }

    .tasks-container::-webkit-scrollbar-thumb:hover {
      background: var(--border-hover);
    }

    .help-text {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background-color: var(--surface-elevated);
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 0.8rem;
      color: var(--text-muted);
      opacity: 0.8;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
    }

    .sync-indicator {
      position: fixed;
      bottom: 24px;
      left: 24px;
      background-color: var(--surface-elevated);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
      opacity: 1;
      transition: all 0.3s ease;
      color: var(--text-muted);
    }

    .sync-indicator.synced {
      color: var(--success);
      border-color: var(--success);
    }

    .sync-indicator.error {
      color: var(--warning);
      border-color: var(--warning);
    }

    .sync-indicator:hover {
      opacity: 1;
    }

    .task-tags {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .task-tag {
      background-color: var(--surface);
      color: var(--text-secondary);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 500;
      border: 1px solid var(--border);
    }

    .task-notes {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--text-secondary);
      font-style: italic;
      line-height: 1.4;
      white-space: pre-wrap;
    }

    .task.on-hold {
      opacity: 0.6;
      border-left: 4px solid var(--warning);
      background: repeating-linear-gradient(45deg,
          var(--surface-elevated),
          var(--surface-elevated) 10px,
          rgba(212, 165, 116, 0.05) 10px,
          rgba(212, 165, 116, 0.05) 20px);
    }

    .task.on-hold .task-title::before {
      content: '‚è∏ ';
      opacity: 0.7;
    }

    .action-btn.hold:hover {
      color: var(--warning);
      border-color: var(--warning);
      background-color: rgba(212, 165, 116, 0.1);
    }

    .date-group {
      margin-bottom: 20px;
    }

    .date-header {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 12px;
      padding: 8px 12px;
      background-color: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .tags-input {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background-color: var(--surface);
      min-height: 44px;
      cursor: text;
      transition: border-color 0.2s ease;
      position: relative;
    }

    .tags-input:focus-within {
      border-color: var(--accent);
    }

    .tag-item {
      background-color: var(--accent);
      color: var(--surface-elevated);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tag-remove {
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      font-size: 0.7rem;
      padding: 0;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tag-remove:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .tag-input {
      border: none;
      background: none;
      color: var(--text-primary);
      outline: none;
      flex: 1;
      min-width: 100px;
      font-size: 0.9rem;
    }

    .tag-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--surface-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: var(--shadow-md);
      max-height: 150px;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }

    .tag-suggestion {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.9rem;
      color: var(--text-primary);
      transition: background-color 0.2s ease;
    }

    .tag-suggestion:hover,
    .tag-suggestion.selected {
      background-color: var(--surface);
    }

    .task-time-info {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .time-started {
      font-size: 0.8rem;
      color: var(--text-muted);
      cursor: pointer;
      transition: color 0.2s ease;
      display: inline-block;
    }

    .time-started:hover {
      color: var(--accent);
      text-decoration: underline;
    }

    .task-total-time {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--text-muted);
      font-style: italic;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .task-total-time .time-icon {
      font-size: 0.9rem;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="title-container">
      <h1 id="app-title">Tobi's Task Manager</h1>
      <button class="title-edit-btn" id="title-edit-btn" onclick="toggleTitleEdit()">Edit</button>
    </div>

    <div class="board">
      <div class="column" data-column="todo">
        <div class="column-header todo" onclick="toggleColumn('todo')">To Do</div>
        <div class="tasks-container" id="todo-tasks"></div>
        <div class="add-task-btn" onclick="openTaskModal('todo')">
          + Add Task
        </div>
      </div>

      <div class="column" data-column="in-progress">
        <div class="column-header in-progress" onclick="toggleColumn('in-progress')">In Progress</div>
        <div class="tasks-container" id="in-progress-tasks"></div>
        <div class="add-task-btn" onclick="openTaskModal('in-progress')">
          + Add Task
        </div>
      </div>

      <div class="column" data-column="done">
        <div class="column-header done" onclick="toggleColumn('done')">Done</div>
        <div class="tasks-container" id="done-tasks"></div>
        <div class="add-task-btn" onclick="openTaskModal('done')">
          + Add Task
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="task-modal">
    <div class="modal-content">
      <h3 id="modal-title">Add Task</h3>
      <div class="form-group">
        <label for="task-title">Title</label>
        <input type="text" id="task-title" placeholder="Enter task title">
      </div>
      <div class="form-group">
        <label for="task-url">URL (optional)</label>
        <input type="url" id="task-url" placeholder="https://example.com">
      </div>
      <div class="form-group">
        <label for="task-tags">Tags (optional)</label>
        <div class="tags-input" id="tags-input">
          <input type="text" class="tag-input" id="tag-input" placeholder="Type and press Enter to add tags">
        </div>
      </div>
      <div class="form-group">
        <label for="task-notes">Notes (optional)</label>
        <textarea id="task-notes" placeholder="Add any additional notes..."></textarea>
      </div>
      <div class="form-group">
        <label for="task-started">Started At (optional)</label>
        <input type="datetime-local" id="task-started" placeholder="When did you start working on this?">
      </div>
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="closeTaskModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveTask()">Save</button>
      </div>
    </div>
  </div>

  <div class="sync-indicator" id="sync-indicator">Loading...</div>

  <div class="help-text">
    Tip: Press Cmd+V to paste a URL ‚Ä¢ Arrow keys to navigate ‚Ä¢ Shift+Arrow to move tasks ‚Ä¢ Enter to edit ‚Ä¢ N for new
    task
  </div>

  <script>
    let tasks = [];
    let selectedTaskId = null;
    let currentEditingTask = null;
    let currentColumn = 'todo';
    let currentTags = [];
    let collapsedColumns = new Set();
    let selectedColumn = 0; // 0=todo, 1=in-progress, 2=done
    const columnNames = ['todo', 'in-progress', 'done'];
    let allTags = new Set();
    let tagSuggestions = [];
    let isServerMode = window.location.protocol !== 'file:';
    let lastSavedTime = null;

    // Clean up old time tracking data
    function migrateTimeTrackingData(task) {
      // Remove old time tracking fields
      if (task.timeEntries) delete task.timeEntries;
      if (task.isTracking) delete task.isTracking;
      if (task.trackingStartedAt) delete task.trackingStartedAt;
      if (task.totalTime) delete task.totalTime;

      return task;
    }

    // Load tasks from server or localStorage
    async function loadTasks() {
      if (isServerMode) {
        try {
          const response = await fetch('/tasks.json');
          if (response.ok) {
            const serverTasks = await response.json();
            tasks = serverTasks.map(migrateTimeTrackingData);
            collectAllTags();
            renderTasks();
            // Also sync to localStorage as backup
            localStorage.setItem('taskManager_tasks', JSON.stringify(tasks));
            return;
          }
        } catch (error) {
          console.log('Could not load from server, falling back to localStorage');
        }
      }

      // Fallback to localStorage
      const savedTasks = localStorage.getItem('taskManager_tasks');
      if (savedTasks) {
        tasks = JSON.parse(savedTasks).map(migrateTimeTrackingData);
        collectAllTags();
        renderTasks();
      }
    }

    // Collect all unique tags from tasks
    function collectAllTags() {
      allTags.clear();
      tasks.forEach(task => {
        if (task.tags) {
          task.tags.forEach(tag => allTags.add(tag));
        }
      });
    }

    // Save tasks to localStorage and server
    async function saveTasks() {
      localStorage.setItem('taskManager_tasks', JSON.stringify(tasks));
      collectAllTags();

      // Save to server if in server mode
      if (isServerMode) {
        try {
          const response = await fetch('/save-tasks', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(tasks)
          });

          if (response.ok) {
            updateSyncStatus('synced');
          } else {
            updateSyncStatus('error');
          }
        } catch (error) {
          updateSyncStatus('error');
        }
      } else {
        updateSyncStatus('synced');
      }
    }

    // Format timestamp for display
    function formatLastSaved(timestamp) {
      if (!timestamp) return '';

      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);

      if (diffMins < 1) return 'just now';
      if (diffMins === 1) return '1 min ago';
      if (diffMins < 60) return `${diffMins} mins ago`;

      const diffHours = Math.floor(diffMins / 60);
      if (diffHours === 1) return '1 hour ago';
      if (diffHours < 24) return `${diffHours} hours ago`;

      // Show actual time for older saves
      return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
    }

    // Time tracking utility functions
    function formatTime(milliseconds) {
      if (!milliseconds || milliseconds < 0) return '0m';

      const seconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) {
        const remainingHours = hours % 24;
        if (remainingHours > 0) {
          return `${days}d ${remainingHours}h`;
        }
        return `${days}d`;
      } else if (hours > 0) {
        const remainingMinutes = minutes % 60;
        if (remainingMinutes > 0) {
          return `${hours}h ${remainingMinutes}m`;
        }
        return `${hours}h`;
      } else if (minutes > 0) {
        return `${minutes}m`;
      } else {
        return `${seconds}s`;
      }
    }

    function calculateTaskDuration(task) {
      // Only calculate duration for tasks that have both start and completion time
      if (!task.startedAt || !task.completedAt) return 0;

      const start = new Date(task.startedAt).getTime();
      const end = new Date(task.completedAt).getTime();

      return end - start;
    }

    function formatDateTime(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
    }

    // Update sync status indicator
    function updateSyncStatus(status) {
      const indicator = document.getElementById('sync-indicator');
      if (!indicator) return;

      indicator.className = 'sync-indicator';

      if (status === 'synced') {
        lastSavedTime = new Date();
        indicator.classList.add('synced');
        indicator.textContent = `‚úì Saved ${formatLastSaved(lastSavedTime)}`;
        localStorage.setItem('taskManager_lastSaved', lastSavedTime.toISOString());
      } else if (status === 'error') {
        indicator.classList.add('error');
        if (lastSavedTime) {
          indicator.textContent = `‚ö† Last saved ${formatLastSaved(lastSavedTime)} (local only)`;
        } else {
          indicator.textContent = '‚ö† Not synced (local only)';
        }
      }
    }

    // Update the "time ago" text periodically
    function refreshSyncTimestamp() {
      if (lastSavedTime) {
        const indicator = document.getElementById('sync-indicator');
        if (indicator && indicator.classList.contains('synced')) {
          indicator.textContent = `‚úì Saved ${formatLastSaved(lastSavedTime)}`;
        }
      }
    }

    // Generate unique ID
    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Render all tasks
    function renderTasks() {
      const columns = ['todo', 'in-progress', 'done'];

      columns.forEach(column => {
        const container = document.getElementById(`${column}-tasks`);
        container.innerHTML = '';

        let columnTasks = tasks.filter(task => task.column === column);

        if (column === 'done') {
          // Group done tasks by completion date
          const tasksByDate = groupTasksByDate(columnTasks);

          Object.keys(tasksByDate)
            .sort((a, b) => new Date(b) - new Date(a)) // Sort dates descending
            .forEach(date => {
              const dateGroup = document.createElement('div');
              dateGroup.className = 'date-group';

              const dateHeader = document.createElement('div');
              dateHeader.className = 'date-header';
              dateHeader.textContent = formatDateHeader(date);
              dateGroup.appendChild(dateHeader);

              // Sort tasks within date by completion time (descending)
              tasksByDate[date]
                .sort((a, b) => new Date(b.completedAt || b.createdAt) - new Date(a.completedAt || a.createdAt))
                .forEach(task => {
                  const taskElement = createTaskElement(task, tasks.indexOf(task));
                  dateGroup.appendChild(taskElement);
                });

              container.appendChild(dateGroup);
            });
        } else {
          // Sort by order field for todo and in-progress columns
          columnTasks.sort((a, b) => (a.order || 0) - (b.order || 0));
          columnTasks.forEach((task, index) => {
            const taskElement = createTaskElement(task, tasks.indexOf(task));
            container.appendChild(taskElement);
          });
        }

      });
    }

    // Update task order within column based on DOM order
    function updateTaskOrder(container, column) {
      const taskElements = [...container.querySelectorAll('.task')];
      taskElements.forEach((element, index) => {
        const elementTaskId = element.dataset.taskId;
        const task = tasks.find(t => t.id === elementTaskId);
        if (task) {
          task.order = index;
        }
      });
    }

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.task:not(.dragging)')];

      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;

        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Group tasks by date
    function groupTasksByDate(tasks) {
      const groups = {};
      tasks.forEach(task => {
        const date = task.completedAt ?
          new Date(task.completedAt).toDateString() :
          new Date(task.createdAt).toDateString();

        if (!groups[date]) {
          groups[date] = [];
        }
        groups[date].push(task);
      });
      return groups;
    }

    // Format date header
    function formatDateHeader(dateString) {
      const date = new Date(dateString);
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);

      if (date.toDateString() === today.toDateString()) {
        return 'Today';
      } else if (date.toDateString() === yesterday.toDateString()) {
        return 'Yesterday';
      } else {
        return date.toLocaleDateString('en-US', {
          weekday: 'long',
          month: 'short',
          day: 'numeric'
        });
      }
    }

    // Toggle column collapse
    function toggleColumn(columnName) {
      const column = document.querySelector(`[data-column="${columnName}"]`);
      if (collapsedColumns.has(columnName)) {
        collapsedColumns.delete(columnName);
        column.classList.remove('collapsed');
      } else {
        collapsedColumns.add(columnName);
        column.classList.add('collapsed');
      }
      localStorage.setItem('taskManager_collapsedColumns', JSON.stringify([...collapsedColumns]));
    }

    // Load collapsed state
    function loadCollapsedState() {
      const saved = localStorage.getItem('taskManager_collapsedColumns');
      if (saved) {
        collapsedColumns = new Set(JSON.parse(saved));
        collapsedColumns.forEach(columnName => {
          const column = document.querySelector(`[data-column="${columnName}"]`);
          if (column) column.classList.add('collapsed');
        });
      }
    }

    // Create task element
    function createTaskElement(task, index) {
      const taskDiv = document.createElement('div');
      taskDiv.className = 'task';
      taskDiv.draggable = true;
      taskDiv.dataset.taskId = task.id;
      taskDiv.dataset.index = index;

      const isDone = task.column === 'done';
      const duration = calculateTaskDuration(task);

      // Build time info HTML
      let timeInfoHTML = '';
      if (task.startedAt) {
        const startTimeDisplay = formatDateTime(task.startedAt);
        timeInfoHTML = `
          <div class="task-time-info">
            <span class="time-started" onclick="editStartTime(event, '${task.id}')" title="Click to edit start time">
              üìÖ Started: ${startTimeDisplay}
            </span>
          </div>
        `;
      }

      // For done tasks, show duration
      if (isDone && duration > 0) {
        timeInfoHTML += `
          <div class="task-total-time">
            <span class="time-icon">‚è±</span>
            <span>Completed in ${formatTime(duration)}</span>
          </div>
        `;
      }

      taskDiv.innerHTML = `
                <div class="task-actions">
                    <button class="action-btn hold" onclick="toggleHold('${task.id}')" title="${task.onHold ? 'Resume' : 'Put on Hold'}">${task.onHold ? '‚ñ∂Ô∏è' : '‚è∏'}</button>
                    <button class="action-btn edit" onclick="editTaskByIdFromButton('${task.id}')" title="Edit">‚úèÔ∏è</button>
                    <button class="action-btn duplicate" onclick="duplicateTaskByIdFromButton('${task.id}')" title="Duplicate">üìã</button>
                    <button class="action-btn delete" onclick="deleteTaskByIdFromButton('${task.id}')" title="Delete">üóëÔ∏è</button>
                </div>
                <div class="task-title">${task.title}</div>
                ${task.url ? `<div class="task-url-container"><img src="${getFaviconUrl(task.url)}" class="task-favicon" onerror="this.style.display='none'"><a href="${task.url}" target="_blank" class="task-url">${task.url}</a></div>` : ''}
                ${task.tags && task.tags.length > 0 ? `<div class="task-tags">${task.tags.map(tag => `<span class="task-tag">${tag}</span>`).join('')}</div>` : ''}
                ${task.notes ? `<div class="task-notes">${escapeHtml(task.notes)}</div>` : ''}
                ${timeInfoHTML}
            `;

      // Add on-hold class if task is on hold
      if (task.onHold) {
        taskDiv.classList.add('on-hold');
      }

      // Drag events (all tasks are draggable)
      taskDiv.addEventListener('dragstart', handleDragStart);
      taskDiv.addEventListener('dragend', handleDragEnd);

      // Click events
      taskDiv.addEventListener('click', () => selectTask(task.id));
      taskDiv.addEventListener('dblclick', () => editTaskByIdFromButton(task.id));

      return taskDiv;
    }

    // Drag and drop functionality
    function handleDragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.taskId);
      e.target.classList.add('dragging');
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
    }

    // Set up drop zones after DOM is loaded
    function setupDropZones() {
      document.querySelectorAll('.tasks-container').forEach(container => {
        container.addEventListener('dragover', handleDragOver);
        container.addEventListener('drop', handleDrop);
        container.addEventListener('dragenter', handleDragEnter);
        container.addEventListener('dragleave', handleDragLeave);
      });
    }

    function handleDragOver(e) {
      e.preventDefault();

      const dragging = document.querySelector('.dragging');
      if (!dragging) return;

      const container = e.currentTarget;
      const newColumn = container.id.replace('-tasks', '');
      const draggingTaskId = dragging.dataset.taskId;
      const draggingTask = tasks.find(t => t.id === draggingTaskId);

      if (!draggingTask) return;

      // If dragging within the same column and it's not Done, allow reordering
      if (draggingTask.column === newColumn && newColumn !== 'done') {
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement == null) {
          container.appendChild(dragging);
        } else {
          container.insertBefore(dragging, afterElement);
        }
      }
    }

    function handleDragEnter(e) {
      e.preventDefault();
      e.currentTarget.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      if (!e.currentTarget.contains(e.relatedTarget)) {
        e.currentTarget.classList.remove('drag-over');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');

      const taskId = e.dataTransfer.getData('text/plain');
      const newColumn = e.currentTarget.id.replace('-tasks', '');
      const dragging = document.querySelector('.dragging');

      const taskIndex = tasks.findIndex(task => task.id === taskId);
      if (taskIndex !== -1) {
        const oldColumn = tasks[taskIndex].column;

        // Check if we're moving between columns or reordering within column
        if (oldColumn !== newColumn) {
          // Moving between columns
          tasks[taskIndex].column = newColumn;

          // If moving to done, set completion timestamp
          if (newColumn === 'done' && oldColumn !== 'done') {
            tasks[taskIndex].completedAt = new Date().toISOString();
          } else if (oldColumn === 'done' && newColumn !== 'done') {
            // If moving out of done, remove completion timestamp
            delete tasks[taskIndex].completedAt;
          }

          // Reset order when moving between columns
          const columnTasks = tasks.filter(task => task.column === newColumn && task.id !== taskId);
          tasks[taskIndex].order = columnTasks.length;
        } else {
          // Reordering within same column (only allowed for todo and in-progress)
          if (newColumn !== 'done') {
            updateTaskOrder(e.currentTarget, newColumn);
          }
        }

        saveTasks();
        renderTasks();
      }
    }

    // Task modal functions
    function openTaskModal(column = 'todo') {
      currentColumn = column;
      currentEditingTask = null;
      currentTags = [];
      document.getElementById('modal-title').textContent = 'Add Task';
      document.getElementById('task-title').value = '';
      document.getElementById('task-url').value = '';
      document.getElementById('task-notes').value = '';
      document.getElementById('task-started').value = '';
      renderTagsInput();
      document.getElementById('task-modal').style.display = 'block';
      document.getElementById('task-title').focus();
    }

    function closeTaskModal() {
      document.getElementById('task-modal').style.display = 'none';
    }

    function editTask(index) {
      const task = tasks[index];
      currentEditingTask = index;
      currentColumn = task.column;
      currentTags = task.tags ? [...task.tags] : [];
      document.getElementById('modal-title').textContent = 'Edit Task';
      document.getElementById('task-title').value = task.title;
      document.getElementById('task-url').value = task.url || '';
      document.getElementById('task-notes').value = task.notes || '';

      // Set started time if it exists
      if (task.startedAt) {
        const date = new Date(task.startedAt);
        const localDateTime = new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
        document.getElementById('task-started').value = localDateTime;
      } else {
        document.getElementById('task-started').value = '';
      }

      renderTagsInput();
      document.getElementById('task-modal').style.display = 'block';
      document.getElementById('task-title').focus();
    }

    function deleteTask(index) {
      if (confirm('Are you sure you want to delete this task?')) {
        tasks.splice(index, 1);
        saveTasks();
        renderTasks();
      }
    }

    // Helper functions for button clicks that use task IDs
    function editTaskByIdFromButton(taskId) {
      const taskIndex = tasks.findIndex(t => t.id === taskId);
      if (taskIndex >= 0) {
        editTask(taskIndex);
      }
    }

    function deleteTaskByIdFromButton(taskId) {
      const taskIndex = tasks.findIndex(t => t.id === taskId);
      if (taskIndex >= 0) {
        // Clear selection if deleting selected task
        if (selectedTaskId === taskId) {
          selectedTaskId = null;
        }
        deleteTask(taskIndex);
      }
    }

    function duplicateTaskByIdFromButton(taskId) {
      const taskIndex = tasks.findIndex(t => t.id === taskId);
      if (taskIndex >= 0) {
        duplicateTask(taskIndex);
      }
    }

    function duplicateTask(index) {
      const originalTask = tasks[index];

      // Increment order of all existing tasks in the same column
      tasks.forEach(task => {
        if (task.column === originalTask.column) {
          task.order = (task.order || 0) + 1;
        }
      });

      // Create duplicate task
      const duplicatedTask = {
        id: generateId(),
        title: originalTask.title,
        url: originalTask.url || '',
        notes: originalTask.notes || '',
        tags: originalTask.tags ? [...originalTask.tags] : [],
        column: originalTask.column,
        order: 0,
        createdAt: new Date().toISOString(),
        onHold: originalTask.onHold || false
      };

      // Remove completedAt and startedAt for duplicated task
      // (they are not copied, so they won't exist in the new task)

      tasks.push(duplicatedTask);
      saveTasks();
      renderTasks();

      // Select the newly duplicated task
      selectTask(duplicatedTask.id);
    }

    function saveTask() {
      const title = document.getElementById('task-title').value.trim();
      const url = document.getElementById('task-url').value.trim();
      const notes = document.getElementById('task-notes').value.trim();
      const startedValue = document.getElementById('task-started').value;

      if (!title) {
        alert('Please enter a task title');
        return;
      }

      // Convert local datetime to ISO string
      const startedAt = startedValue ? new Date(startedValue).toISOString() : null;

      if (currentEditingTask !== null) {
        // Edit existing task
        tasks[currentEditingTask].title = title;
        tasks[currentEditingTask].url = url;
        tasks[currentEditingTask].notes = notes;
        tasks[currentEditingTask].tags = currentTags;
        if (startedAt) {
          tasks[currentEditingTask].startedAt = startedAt;
        } else {
          delete tasks[currentEditingTask].startedAt;
        }
      } else {
        // Create new task at the top (order 0)
        // First, increment the order of all existing tasks in this column
        tasks.forEach(task => {
          if (task.column === currentColumn) {
            task.order = (task.order || 0) + 1;
          }
        });

        const task = {
          id: generateId(),
          title: title,
          url: url,
          notes: notes,
          tags: currentTags,
          column: currentColumn,
          order: 0,
          createdAt: new Date().toISOString()
        };

        if (startedAt) {
          task.startedAt = startedAt;
        }

        tasks.push(task);
      }

      saveTasks();
      renderTasks();
      closeTaskModal();
    }

    // Task selection for navigation
    function selectTask(taskId) {
      // Remove previous selection
      document.querySelectorAll('.task.selected').forEach(task => {
        task.classList.remove('selected');
      });

      selectedTaskId = taskId;
      const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
      if (taskElement) {
        taskElement.classList.add('selected');
        taskElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

        // Update selected column based on task location
        const task = tasks.find(t => t.id === taskId);
        if (task) {
          selectedColumn = columnNames.indexOf(task.column);
        }
      }
    }

    function clearSelection() {
      document.querySelectorAll('.task.selected').forEach(task => {
        task.classList.remove('selected');
      });
      selectedTaskId = null;
    }

    function getSelectedTask() {
      return selectedTaskId ? tasks.find(t => t.id === selectedTaskId) : null;
    }

    // Get tasks in visual order for a column
    function getColumnTasksInOrder(columnName) {
      const container = document.getElementById(`${columnName}-tasks`);
      if (!container) return [];

      const taskElements = container.querySelectorAll('.task');
      return Array.from(taskElements).map(element => {
        const taskId = element.dataset.taskId;
        return tasks.find(task => task.id === taskId);
      }).filter(task => task);
    }

    // Navigation functions
    function navigateUp() {
      const columnName = columnNames[selectedColumn];
      const columnTasks = getColumnTasksInOrder(columnName);
      if (columnTasks.length === 0) return;

      if (!selectedTaskId) {
        selectTask(columnTasks[0].id);
        return;
      }

      const currentIndex = columnTasks.findIndex(t => t.id === selectedTaskId);
      if (currentIndex > 0) {
        selectTask(columnTasks[currentIndex - 1].id);
      } else {
        selectTask(columnTasks[columnTasks.length - 1].id);
      }
    }

    function navigateDown() {
      const columnName = columnNames[selectedColumn];
      const columnTasks = getColumnTasksInOrder(columnName);
      if (columnTasks.length === 0) return;

      if (!selectedTaskId) {
        selectTask(columnTasks[0].id);
        return;
      }

      const currentIndex = columnTasks.findIndex(t => t.id === selectedTaskId);
      if (currentIndex < columnTasks.length - 1) {
        selectTask(columnTasks[currentIndex + 1].id);
      } else {
        selectTask(columnTasks[0].id);
      }
    }

    function navigateLeft() {
      selectedColumn = selectedColumn > 0 ? selectedColumn - 1 : columnNames.length - 1;
      const columnTasks = getColumnTasksInOrder(columnNames[selectedColumn]);
      if (columnTasks.length > 0) {
        selectTask(columnTasks[0].id);
      } else {
        clearSelection();
      }
    }

    function navigateRight() {
      selectedColumn = selectedColumn < columnNames.length - 1 ? selectedColumn + 1 : 0;
      const columnTasks = getColumnTasksInOrder(columnNames[selectedColumn]);
      if (columnTasks.length > 0) {
        selectTask(columnTasks[0].id);
      } else {
        clearSelection();
      }
    }

    // Move task functions
    function moveTaskUp() {
      const task = getSelectedTask();
      if (!task || task.column === 'done') return;

      const columnTasks = getColumnTasksInOrder(task.column);
      const currentIndex = columnTasks.findIndex(t => t.id === task.id);

      if (currentIndex > 0) {
        const targetTask = columnTasks[currentIndex - 1];
        const tempOrder = task.order;
        task.order = targetTask.order;
        targetTask.order = tempOrder;

        saveTasks();
        renderTasks();
        selectTask(task.id);
      }
    }

    function moveTaskDown() {
      const task = getSelectedTask();
      if (!task || task.column === 'done') return;

      const columnTasks = getColumnTasksInOrder(task.column);
      const currentIndex = columnTasks.findIndex(t => t.id === task.id);

      if (currentIndex < columnTasks.length - 1) {
        const targetTask = columnTasks[currentIndex + 1];
        const tempOrder = task.order;
        task.order = targetTask.order;
        targetTask.order = tempOrder;

        saveTasks();
        renderTasks();
        selectTask(task.id);
      }
    }

    function moveTaskLeft() {
      const task = getSelectedTask();
      if (!task) return;

      const newColumnIndex = selectedColumn > 0 ? selectedColumn - 1 : columnNames.length - 1;
      const newColumnName = columnNames[newColumnIndex];
      const oldColumn = task.column;

      task.column = newColumnName;

      if (newColumnName === 'done' && oldColumn !== 'done') {
        task.completedAt = new Date().toISOString();
      } else if (oldColumn === 'done' && newColumnName !== 'done') {
        delete task.completedAt;
      }

      const newColumnTasks = tasks.filter(t => t.column === newColumnName && t.id !== task.id);
      task.order = newColumnTasks.length;

      selectedColumn = newColumnIndex;
      saveTasks();
      renderTasks();
      selectTask(task.id);
    }

    function moveTaskRight() {
      const task = getSelectedTask();
      if (!task) return;

      const newColumnIndex = selectedColumn < columnNames.length - 1 ? selectedColumn + 1 : 0;
      const newColumnName = columnNames[newColumnIndex];
      const oldColumn = task.column;

      task.column = newColumnName;

      if (newColumnName === 'done' && oldColumn !== 'done') {
        task.completedAt = new Date().toISOString();
      } else if (oldColumn === 'done' && newColumnName !== 'done') {
        delete task.completedAt;
      }

      const newColumnTasks = tasks.filter(t => t.column === newColumnName && t.id !== task.id);
      task.order = newColumnTasks.length;

      selectedColumn = newColumnIndex;
      saveTasks();
      renderTasks();
      selectTask(task.id);
    }

    // URL detection and title fetching
    function isValidUrl(string) {
      try {
        new URL(string);
        return true;
      } catch (_) {
        return false;
      }
    }

    // Get favicon URL for a given website URL
    function getFaviconUrl(url) {
      try {
        const domain = new URL(url).origin;
        return `${domain}/favicon.ico`;
      } catch (_) {
        return '';
      }
    }

    async function fetchPageTitle(url) {
      try {
        const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(url)}`);
        const data = await response.json();
        const parser = new DOMParser();
        const doc = parser.parseFromString(data.contents, 'text/html');
        const title = doc.querySelector('title');
        return title ? title.textContent.trim() : new URL(url).hostname;
      } catch (error) {
        console.error('Error fetching page title:', error);
        return new URL(url).hostname;
      }
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Prevent shortcuts when modal is open or in input fields
      if (document.getElementById('task-modal').style.display === 'block' ||
        e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }

      if (e.shiftKey) {
        // Shift + Arrow = Move task
        switch (e.key) {
          case 'ArrowUp':
            moveTaskUp();
            e.preventDefault();
            break;
          case 'ArrowDown':
            moveTaskDown();
            e.preventDefault();
            break;
          case 'ArrowLeft':
            moveTaskLeft();
            e.preventDefault();
            break;
          case 'ArrowRight':
            moveTaskRight();
            e.preventDefault();
            break;
        }
      } else {
        // Regular navigation and actions
        switch (e.key) {
          case 'ArrowUp':
            navigateUp();
            e.preventDefault();
            break;
          case 'ArrowDown':
            navigateDown();
            e.preventDefault();
            break;
          case 'ArrowLeft':
            navigateLeft();
            e.preventDefault();
            break;
          case 'ArrowRight':
            navigateRight();
            e.preventDefault();
            break;
          case 'Enter':
            if (selectedTaskId) {
              const taskIndex = tasks.findIndex(t => t.id === selectedTaskId);
              if (taskIndex >= 0) {
                editTask(taskIndex);
              }
            }
            e.preventDefault();
            break;
          case 'Delete':
          case 'Backspace':
            if (selectedTaskId) {
              const taskIndex = tasks.findIndex(t => t.id === selectedTaskId);
              if (taskIndex >= 0) {
                deleteTask(taskIndex);
              }
            }
            e.preventDefault();
            break;
          case 'n':
          case 'N':
            // Always add new tasks to the "todo" column when pressing 'n'
            openTaskModal('todo');
            e.preventDefault();
            break;
        }
      }
    });

    // Paste functionality
    document.addEventListener('paste', async (e) => {
      // Only handle paste when not in input fields or modal
      if (e.target.tagName === 'INPUT' ||
        document.getElementById('task-modal').style.display === 'block') {
        return;
      }

      e.preventDefault();
      const pastedText = e.clipboardData.getData('text').trim();

      if (isValidUrl(pastedText)) {
        // Open modal immediately with URL pre-filled
        currentColumn = 'todo';
        currentEditingTask = null;
        document.getElementById('modal-title').textContent = 'Add Task';
        currentTags = [];
        document.getElementById('task-title').value = '';
        document.getElementById('task-url').value = pastedText;
        document.getElementById('task-notes').value = '';
        renderTagsInput();
        document.getElementById('task-modal').style.display = 'block';
        document.getElementById('task-title').focus();
      }
    });

    // Modal keyboard shortcuts and click outside to close
    document.getElementById('task-modal').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeTaskModal();
      } else if (e.key === 'Enter' && e.target.id !== 'task-notes' && e.target.id !== 'tag-input') {
        saveTask();
      } else if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
        saveTask();
      }
    });

    // Close modal when clicking outside of it
    document.getElementById('task-modal').addEventListener('click', (e) => {
      if (e.target.id === 'task-modal') {
        closeTaskModal();
      }
    });

    // Tags functionality
    function renderTagsInput() {
      const container = document.getElementById('tags-input');
      container.innerHTML = '';

      currentTags.forEach((tag, index) => {
        const tagElement = document.createElement('div');
        tagElement.className = 'tag-item';
        tagElement.innerHTML = `
                    <span>${tag}</span>
                    <button class="tag-remove" onclick="removeTag(${index})" type="button">√ó</button>
                `;
        container.appendChild(tagElement);
      });

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'tag-input';
      input.id = 'tag-input';
      input.placeholder = currentTags.length === 0 ? 'Type and press Enter to add tags' : '';
      input.addEventListener('keydown', handleTagInput);
      input.addEventListener('input', handleTagInputChange);
      input.addEventListener('blur', hideSuggestions);
      container.appendChild(input);

      const suggestionsDiv = document.createElement('div');
      suggestionsDiv.className = 'tag-suggestions';
      suggestionsDiv.id = 'tag-suggestions';
      container.appendChild(suggestionsDiv);
    }

    function handleTagInput(e) {
      const suggestions = document.getElementById('tag-suggestions');
      const selectedSuggestion = suggestions.querySelector('.tag-suggestion.selected');

      if (e.key === 'Enter') {
        e.preventDefault();
        if (selectedSuggestion) {
          addTag(selectedSuggestion.textContent);
          e.target.value = '';
          hideSuggestions();
        } else if (e.target.value.trim()) {
          addTag(e.target.value.trim());
          e.target.value = '';
          hideSuggestions();
        }
      } else if (e.key === 'Backspace' && e.target.value === '' && currentTags.length > 0) {
        removeTag(currentTags.length - 1);
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectNextSuggestion();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectPrevSuggestion();
      } else if (e.key === 'Escape') {
        hideSuggestions();
      }
    }

    function handleTagInputChange(e) {
      const query = e.target.value.trim().toLowerCase();
      if (query.length > 0) {
        showSuggestions(query);
      } else {
        hideSuggestions();
      }
    }

    function showSuggestions(query) {
      const suggestions = document.getElementById('tag-suggestions');
      const filteredTags = Array.from(allTags)
        .filter(tag =>
          tag.toLowerCase().includes(query) &&
          !currentTags.includes(tag)
        )
        .slice(0, 5);

      if (filteredTags.length > 0) {
        suggestions.innerHTML = filteredTags
          .map(tag => `<div class="tag-suggestion" onclick="selectSuggestion('${tag}')">${tag}</div>`)
          .join('');
        suggestions.style.display = 'block';
      } else {
        hideSuggestions();
      }
    }

    function hideSuggestions() {
      setTimeout(() => {
        const suggestions = document.getElementById('tag-suggestions');
        if (suggestions) {
          suggestions.style.display = 'none';
        }
      }, 150);
    }

    function selectSuggestion(tag) {
      addTag(tag);
      document.getElementById('tag-input').value = '';
      hideSuggestions();
      document.getElementById('tag-input').focus();
    }

    function selectNextSuggestion() {
      const suggestions = document.querySelectorAll('.tag-suggestion');
      const current = document.querySelector('.tag-suggestion.selected');

      if (suggestions.length === 0) return;

      if (!current) {
        suggestions[0].classList.add('selected');
      } else {
        current.classList.remove('selected');
        const nextIndex = Array.from(suggestions).indexOf(current) + 1;
        if (nextIndex < suggestions.length) {
          suggestions[nextIndex].classList.add('selected');
        } else {
          suggestions[0].classList.add('selected');
        }
      }
    }

    function selectPrevSuggestion() {
      const suggestions = document.querySelectorAll('.tag-suggestion');
      const current = document.querySelector('.tag-suggestion.selected');

      if (suggestions.length === 0) return;

      if (!current) {
        suggestions[suggestions.length - 1].classList.add('selected');
      } else {
        current.classList.remove('selected');
        const prevIndex = Array.from(suggestions).indexOf(current) - 1;
        if (prevIndex >= 0) {
          suggestions[prevIndex].classList.add('selected');
        } else {
          suggestions[suggestions.length - 1].classList.add('selected');
        }
      }
    }

    function addTag(tagText) {
      if (tagText && !currentTags.includes(tagText)) {
        currentTags.push(tagText);
        renderTagsInput();
        document.getElementById('tag-input').focus();
      }
    }

    function removeTag(index) {
      currentTags.splice(index, 1);
      renderTagsInput();
      document.getElementById('tag-input').focus();
    }

    // Toggle on hold status
    function toggleHold(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (task) {
        task.onHold = !task.onHold;
        saveTasks();
        renderTasks();
        // Restore selection after render
        if (selectedTaskId === taskId) {
          selectTask(taskId);
        }
      }
    }

    // Edit start time function
    function editStartTime(event, taskId) {
      event.stopPropagation();

      const task = tasks.find(t => t.id === taskId);
      if (!task) return;

      const currentValue = task.startedAt ? new Date(task.startedAt) : new Date();
      const localDateTime = new Date(currentValue.getTime() - currentValue.getTimezoneOffset() * 60000).toISOString().slice(0, 16);

      const newValue = prompt('Edit start time (leave empty to remove):', localDateTime);

      if (newValue === null) return; // User clicked cancel

      if (newValue.trim() === '') {
        // Remove start time
        delete task.startedAt;
      } else {
        // Update start time
        try {
          task.startedAt = new Date(newValue).toISOString();
        } catch (e) {
          alert('Invalid date format');
          return;
        }
      }

      saveTasks();
      renderTasks();

      // Restore selection after render
      if (selectedTaskId === taskId) {
        selectTask(taskId);
      }
    }

    // Title editing functions
    function toggleTitleEdit() {
      const editBtn = document.getElementById('title-edit-btn');
      const titleElement = document.getElementById('app-title');
      const container = document.querySelector('.title-container');

      if (editBtn.textContent === 'Edit') {
        // Switch to edit mode
        const currentTitle = titleElement ? titleElement.textContent : "Tobi's Task Manager";
        const editInput = document.createElement('input');
        editInput.type = 'text';
        editInput.className = 'title-edit-input';
        editInput.value = currentTitle;
        editInput.id = 'title-edit-input';

        // Replace h1 with input
        if (titleElement) {
          container.replaceChild(editInput, titleElement);
        } else {
          container.insertBefore(editInput, editBtn);
        }
        editBtn.textContent = 'Save';

        // Focus and select the input
        editInput.focus();
        editInput.select();

        // Handle Enter key and Escape key
        editInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            saveTitle();
          } else if (e.key === 'Escape') {
            cancelTitleEdit();
          }
        });
      } else {
        // Save mode
        saveTitle();
      }
    }

    function saveTitle() {
      const input = document.getElementById('title-edit-input');
      const editBtn = document.getElementById('title-edit-btn');
      const container = document.querySelector('.title-container');

      if (!input) return;

      const newTitle = input.value.trim();
      if (newTitle === '') {
        alert('Title cannot be empty');
        return;
      }

      // Create new h1 element
      const titleElement = document.createElement('h1');
      titleElement.id = 'app-title';
      titleElement.textContent = newTitle;

      // Replace input with h1
      container.replaceChild(titleElement, input);
      editBtn.textContent = 'Edit';

      // Save to localStorage
      localStorage.setItem('taskManager_appName', newTitle);

      // Update document title
      document.title = newTitle;
    }

    function cancelTitleEdit() {
      const input = document.getElementById('title-edit-input');
      const editBtn = document.getElementById('title-edit-btn');
      const container = document.querySelector('.title-container');

      if (!input) return;

      // Restore the original title
      const savedTitle = localStorage.getItem('taskManager_appName') || "Tobi's Task Manager";
      const titleElement = document.createElement('h1');
      titleElement.id = 'app-title';
      titleElement.textContent = savedTitle;

      // Replace input with h1
      container.replaceChild(titleElement, input);
      editBtn.textContent = 'Edit';
    }

    function loadAppName() {
      const savedName = localStorage.getItem('taskManager_appName');
      if (savedName) {
        const titleElement = document.getElementById('app-title');
        if (titleElement) {
          titleElement.textContent = savedName;
        }
        document.title = savedName;
      }
    }

    // Initialize the app
    loadAppName();
    loadTasks();
    loadCollapsedState();
    setupDropZones();

    // Load last saved time from localStorage
    const savedTime = localStorage.getItem('taskManager_lastSaved');
    if (savedTime) {
      lastSavedTime = new Date(savedTime);
      updateSyncStatus('synced');
    } else {
      // Show initial state if no saved time exists
      const indicator = document.getElementById('sync-indicator');
      if (indicator) {
        indicator.textContent = 'Not yet saved';
        indicator.className = 'sync-indicator';
      }
    }

    // Update timestamp display every minute
    setInterval(refreshSyncTimestamp, 60000);

    // Set initial column focus
    setTimeout(() => {
      if (!selectedTaskId && tasks.length > 0) {
        // Find first column with tasks
        for (let i = 0; i < columnNames.length; i++) {
          const columnTasks = getColumnTasksInOrder(columnNames[i]);
          if (columnTasks.length > 0) {
            selectedColumn = i;
            break;
          }
        }
      }
    }, 100);

    // Register service worker for PWA support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered successfully:', registration.scope);
          })
          .catch((error) => {
            console.log('Service Worker registration failed:', error);
          });
      });
    }
  </script>
</body>

</html>
